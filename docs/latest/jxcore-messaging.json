{
  "source": "doc/api/jxcore-messaging.markdown",
  "modules": [
    {
      "textRaw": "JXM.io Messaging Backend",
      "name": "jxm.io_messaging_backend",
      "desc": "<p>Using JXM.io, your clients can easily communicate with the server (backend service) as well as with other clients.\n\n</p>\n<p>Simply create a custom method. It can be invoked either by any of the clients or by the server itself.\n\n</p>\n<p>If you want to create an online game, chat application, or any other project for multiple users – JXM.io is for you.\n\n</p>\n<p>There are some tutorials for using JXM.io available here: <a href=\"http://jxm.io\">jxm.io</a>.\n\n</p>\n",
      "type": "module",
      "displayName": "JXM.io Messaging Backend"
    },
    {
      "textRaw": "API Server",
      "name": "api_server",
      "modules": [
        {
          "textRaw": "Configuration",
          "name": "configuration",
          "desc": "<p>All server settings listed below may be changed using <code>setConfig()</code> method. For example:\n\n</p>\n<pre><code class=\"js\">server.setConfig(&quot;enableClientSideSubscription&quot;, true);</code></pre>\n",
          "modules": [
            {
              "textRaw": "chunked",
              "name": "chunked",
              "desc": "<p>Enables the messaging server to send multiple messages at once to the client.\nThis increases the performance of JXM.io.\nThere are some browser versions, however, that don&#39;t support this feature (for example IE below v8).\nIn this case, chunked mode is internally disabled, even if the <code>chunked</code> option in server is set to <code>true</code>.\n\n</p>\n",
              "type": "module",
              "displayName": "chunked"
            },
            {
              "textRaw": "collectorLatency",
              "name": "collectorlatency",
              "desc": "<p>Defines interval in milliseconds for pushing messages to the clients.\nMessages, that client has sent to the server or other clients are not processed immediately.\nInstead, they are queued and processed together with other messages collected within <code>collectorLatency</code> period.\nThis way the server stays more responsive, because it doesn&#39;t have to deal with each message separately.\n\n</p>\n",
              "type": "module",
              "displayName": "collectorLatency"
            },
            {
              "textRaw": "console",
              "name": "console",
              "desc": "<p>When enabled, the running server displays log and error messages to the console output.\n\n</p>\n",
              "type": "module",
              "displayName": "console"
            },
            {
              "textRaw": "consoleInfo",
              "name": "consoleinfo",
              "desc": "<p>When enabled, the running server displays additional (informative) log messages to the console output.\n\n</p>\n",
              "type": "module",
              "displayName": "consoleInfo"
            },
            {
              "textRaw": "consoleThreadNumber",
              "name": "consolethreadnumber",
              "desc": "<p>When JXM.io server runs in multi-threaded mode and this option is enabled,\neach of the log and error messages displayed to the console contains information about thread ID, from which the message comes.\n\n</p>\n<p>Example output:\n\n</p>\n<pre><code>Thread#1 jxm.io v0.22\nThread#0 jxm.io v0.22\nThread#1 HTTP  -&gt; http://192.168.1.11:8000/test\nThread#0 HTTP  -&gt; http://192.168.1.11:8000/test</code></pre>\n",
              "type": "module",
              "displayName": "consoleThreadNumber"
            },
            {
              "textRaw": "enableClientSideSubscription",
              "name": "enableclientsidesubscription",
              "desc": "<p>When this option is set to <code>false</code> (and it is by default), the client&#39;s methods <code>Subscribe()</code> and <code>Unsubscribe()</code> are disabled.\nHowever, they still exist in client&#39;s API, but invoking them will have no effect, since the calls will be ignored on the server-side.\nClients are still able to send messages to the groups, but since they cannot subscribe to them, it should be done by the server.\nSee server-side methods <code>subscribeClient()</code> and <code>unSubscribeClient()</code>.\n\n</p>\n",
              "type": "module",
              "displayName": "enableClientSideSubscription"
            },
            {
              "textRaw": "encoding",
              "name": "encoding",
              "desc": "<p>Defines encoding type of messages being sent both ways between server and clients.\n\n</p>\n",
              "type": "module",
              "displayName": "encoding"
            },
            {
              "textRaw": "httpsCertLocation",
              "name": "httpsCertLocation",
              "desc": "<p>Both these options define locations for SSL certificate files. See also: <code>httpsServerPort</code> option.\n\n</p>\n",
              "type": "module",
              "displayName": "httpsKeyLocation"
            },
            {
              "textRaw": "httpsKeyLocation",
              "name": "httpskeylocation",
              "desc": "<p>Both these options define locations for SSL certificate files. See also: <code>httpsServerPort</code> option.\n\n</p>\n",
              "type": "module",
              "displayName": "httpsKeyLocation"
            },
            {
              "textRaw": "httpServerPor",
              "name": "httpserverpor",
              "desc": "<p>Defines port for HTTP server of JXM.io backend.\n\n</p>\n",
              "type": "module",
              "displayName": "httpServerPor"
            },
            {
              "textRaw": "httpsServerPort",
              "name": "httpsserverport",
              "desc": "<p>Defines port for HTTPS (SSL) server of JXM.io.\nThe default value 0 also disables SSL support and it means that JXM.io backend will run based on regular HTTP protocol.\nWhen <code>httpsServerPort</code> is set to a number, both <code>httpsCertLocation</code> and <code>httpsKeyLocation</code> should be provided and they must be valid file paths,\notherwise SSL support will not be enabled.\n\n</p>\n",
              "type": "module",
              "displayName": "httpsServerPort"
            },
            {
              "textRaw": "IPAddress",
              "name": "ipaddress",
              "desc": "<p>Defines the IP address, on which HTTP or HTTPS server of JXM.io backend will be running.\nBy default it&#39;s &quot;localhost&quot;, but you may also use any other valid IP address, like &quot;192.168.1.11&quot; or any other.\n\n</p>\n<p>Clients will use this value to connect to the server, so the IP address should be always accessible for them.\nFor example, you should avoid situations in which JXM.io server is configured for IP set to &quot;localhost&quot; or &quot;127.0.0.1&quot;,\nbut clients are connecting from remote machines using server&#39;s public address.\nAlthough this might work, and clients might connect it but this process may generate errors.\nFor example some browsers may fail to use WebSockets and will try to switch to older HTTP protocols.\n\n</p>\n",
              "type": "module",
              "displayName": "IPAddress"
            },
            {
              "textRaw": "listenerTimeout",
              "name": "listenertimeout",
              "desc": "<p>Defines long polling request time in milliseconds. The maximum value should not be greater that 120000 (120 seconds).\n\n</p>\n",
              "type": "module",
              "displayName": "listenerTimeout"
            },
            {
              "textRaw": "mapiVersion",
              "name": "mapiversion",
              "desc": "<p>Contains version number of JXM.io server. For example &quot;0.22&quot;.\nIt is used mostly for informational purpose and is displayed for example, when server starts from the console window.\n\n</p>\n",
              "type": "module",
              "displayName": "mapiVersion"
            }
          ],
          "type": "module",
          "displayName": "Configuration"
        },
        {
          "textRaw": "Error codes",
          "name": "error_codes",
          "desc": "<p>Listed Below are the error codes (and their textual meanings) used by JXM.io.\nWhenever an error occurs while processing a request from the client-side, JXM.io server does not send the full error description back to the client.\nInstead it sends the error code as an integer number.\n\n</p>\n<p>Error codes are defined in JMI.io settings file.\n\n</p>\n<ul>\n<li><code>1</code> - The client does not belong to <strong>this</strong> group. This error occurs when a client tries to send a message to the group, to which is not subscribed.</li>\n<li><code>2</code> - The client does not belong to <strong>any</strong> group.</li>\n<li><code>3</code> - The client tries to subscribe to a group or on-subscribe from it, but the server&#39;s option <a href=\"#jxcore_messaging_enableclientsidesubscription\"><code>enableClientSideSubscription</code></a> is disabled,</li>\n<li><code>4</code> - The client is already subscribed to a specific group.</li>\n<li><code>5</code> - Group information parsing problem. This error occurs, when server is unable to parse group information sent from a client.</li>\n<li><code>6</code> - Group name must be a non-empty string. When client tries to subscribe to a group, but provided an empty string as a group name - then the error occurs.</li>\n<li><code>7</code> - Name of the method was not provided. Invoking client&#39;s <code>Call()</code> method with an empty string as a method name generates this error.</li>\n<li><code>8</code> - Server&#39;s custom method error. This error occurs when custom method defined on the server-side generates an exception.</li>\n<li><code>9</code> - Method is not defined on the server side. The most often reason fo this error is misspelled server&#39;s custom method name.</li>\n</ul>\n",
          "type": "module",
          "displayName": "Error codes"
        },
        {
          "textRaw": "Events",
          "name": "events",
          "modules": [
            {
              "textRaw": "start",
              "name": "start",
              "desc": "<p>This event is raised after the server is successfully started.\nWhen the server is running in multithreaded mode (<a href=\"jxcore-command-mt.html\">mt /mt-keep</a> command), this event occurs for each of the subthreads.\n\n</p>\n<pre><code class=\"js\">server.on(&quot;start&quot;, function() {\n    console.log(&quot;Server started.&quot;);\n});</code></pre>\n",
              "type": "module",
              "displayName": "start"
            },
            {
              "textRaw": "subscribe",
              "name": "subscribe",
              "desc": "<p>Condition for this event to be fired is that server-side <a href=\"#enableclientsidesubscription\"><code>enableClientSideSubscription</code></a> option should be enabled.\nBy default it is set to false, and it means, that clients cannot subscribe to channels nor unsubscribe from them.\nIn such cases, the event <code>subscribe</code> is never raised.\n\n</p>\n<p>When <code>enableClientSideSubscription</code> is set to true, the <code>subscribe</code> event fires whenever client subscribes to a <code>group</code> by calling its <code>Subscribe()</code> method.\nIf no listener is attached to this event, the user always subscribes.\n\n</p>\n<p>Attaching to this event gives you control, whether to allow the user to be subscribed or not.\nThe <code>allow</code> argument is a function, which should be called upon if you want to accept the user&#39;s subscription request.\nOtherwise the user will not be subscribed to a <code>group</code>, and client&#39;s callback will not be invoked.\n\n</p>\n<p>client-side (index.html):\n\n</p>\n<pre><code class=\"js\">var callback = function(group) {\n    alert(&quot;subscribed to &quot; + group);\n};\n\njxcore.Subscribe(&quot;group1&quot;, callback);</code></pre>\n<p>server-side (my_server.js):\n</p>\n<pre><code class=\"js\">server.setConfig(&quot;enableClientSideSubscription&quot;, true);\n\nserver.on(&quot;subscribe&quot;, function(env, params, allow) {\n    // don&#39;t ever subscribe to &quot;admin_group&quot;\n    if (params.group !== &quot;admin_group&quot;) {\n        allow();\n    }\n});</code></pre>\n",
              "type": "module",
              "displayName": "subscribe"
            },
            {
              "textRaw": "unsubscribe",
              "name": "unsubscribe",
              "desc": "<p>Condition for this event to be fired is that server-side <a href=\"#enableclientsidesubscription\"><code>enableClientSideSubscription</code></a> option should be enabled.\nBy default it is set to false, and it means, that clients cannot subscribe to channels nor unsubscribe from them.\nIn such cases, the event <code>unsubscribe</code> is never raised.\n\n</p>\n<p>When <code>enableClientSideSubscription</code> is set to true, the <code>unsubscribe</code> event fires whenever client unsubscribes from a <code>group</code> by calling its <code>Unsubscribe()</code> method.\nIf no listener is attached to this event, the user always unsubscribes.\n\n</p>\n<p>Attaching to this event gives you control, whether to allow the user to be unsubscribed or not.\n\n</p>\n<p>See also <a href=\"#subscribe\">Event: &#39;subscribe&#39;</a>\n\n</p>\n",
              "type": "module",
              "displayName": "unsubscribe"
            },
            {
              "textRaw": "sendToGroup",
              "name": "sendtogroup",
              "desc": "<p>This event fires, whenever user calls <code>SendToGroup()</code> method.\nIf no listener is attached to this event, messages are always sent.\n\n</p>\n<p>Attaching to this event gives you control, whether to allow a particular message to be sent or not.\n\n</p>\n<p>The <code>allow</code> argument is a function, which should be called upon if you want to let the message to be sent.\n\n</p>\n<p>client-side (index.html):\n\n</p>\n<pre><code class=\"js\">    btnSend.onclick = function() {\n        jxcore.SendToGroup(&#39;group1&#39;, &quot;clientsMethod&quot;, { txt: &quot;my_message&quot;} );\n    };</code></pre>\n<p>server-side (my_server.js):\n\n</p>\n<pre><code class=\"js\">server.on(&#39;sendToGroup&#39;, function(env, params, allow) {\n    if (params.group === &quot;group&quot; &amp;&amp; params.method === &quot;clientsMethod&quot;) {\n        allow();\n    }\n});</code></pre>\n",
              "type": "module",
              "displayName": "sendToGroup"
            }
          ],
          "type": "module",
          "displayName": "Events"
        },
        {
          "textRaw": "Object: env",
          "name": "object:_env",
          "desc": "<p>This object is passed to some of the methods described in this document. It contains information about a call made from a client&#39;s side.\nFor example, when a client invokes server&#39;s method by using <code>Call()</code>, the server&#39;s method will receive <code>env</code> object apart from the argument passed to <code>Call()</code>.\n\n</p>\n<p><code>Index</code> represents id of client&#39;s callback and is used by <code>sendCallback()</code> method.\n\n</p>\n",
          "type": "module",
          "displayName": "Object: env"
        },
        {
          "textRaw": "allowedResourceTypes",
          "name": "allowedresourcetypes",
          "desc": "<p>List of supported types for resource files.\n\n</p>\n<ul>\n<li><code>png</code> - image/png</li>\n<li><code>jpg</code> - image/jpeg</li>\n<li><code>jpeg</code> - image/jpeg</li>\n<li><code>gif</code> - image/gif</li>\n<li><code>html</code> - text/html</li>\n<li><code>css</code> - text/css</li>\n<li><code>js</code> - text/javascript</li>\n<li><code>woff</code> - application/octet-stream</li>\n<li><code>ttf</code> - application/octet-stream</li>\n<li><code>svg</code> - application/octet-stream</li>\n<li><code>otf</code> - application/octet-stream</li>\n<li><code>eot</code> - application/octet-stream</li>\n</ul>\n<p>If you want to add new <code>avi</code> type, you can do it like this:\n\n</p>\n<pre><code class=\"js\">server.allowedResourceTypes.avi = &quot;video/avi&quot;;</code></pre>\n<p>Or you can delete the existing one:\n\n</p>\n<pre><code class=\"js\">delete server.allowedResourceTypes.woff;</code></pre>\n",
          "type": "module",
          "displayName": "allowedResourceTypes"
        }
      ],
      "methods": [
        {
          "textRaw": "addJSMethod(name, method)",
          "type": "method",
          "name": "addJSMethod",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`name` {String} ",
                  "name": "name",
                  "type": "String"
                },
                {
                  "textRaw": "`method` {Function} ",
                  "options": [
                    {
                      "textRaw": "`env` {Object} ",
                      "name": "env",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`params` {Object} ",
                      "name": "params",
                      "type": "Object"
                    }
                  ],
                  "name": "method",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "name"
                },
                {
                  "name": "method"
                }
              ]
            }
          ],
          "desc": "<p>Adds custom method to the application and it can be called from the client’s side.\nMethod can receive two parameters: <a href=\"#object-env\"><code>env</code></a> as well as <code>params</code>, which is the value sent by client.\n\n</p>\n<p>client-side (index.html):\n\n</p>\n<pre><code class=\"html\">&lt;script type=&quot;text/javascript&quot;&gt;\n    jxcore.Call(&quot;chatMessage&quot;, &quot;hello&quot;);\n&lt;/script&gt;</code></pre>\n<p>server-side (my_server.js):\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;chatMessage&quot;, function (env, params) {\n    // params contains &quot;Hello&quot; string\n    server.sendToAll(&quot;addText&quot;, params );\n});</code></pre>\n"
        },
        {
          "textRaw": "getConfig(key)",
          "type": "method",
          "name": "getConfig",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`key` {String} ",
                  "name": "key",
                  "type": "String"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "key"
                }
              ]
            }
          ],
          "desc": "<p>Get value of application’s parameter.\n\n</p>\n"
        },
        {
          "textRaw": "linkAssets(urlPath, JXP)",
          "type": "method",
          "name": "linkAssets",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`urlPath` {String} ",
                  "name": "urlPath",
                  "type": "String"
                },
                {
                  "textRaw": "`JXP` {Object} ",
                  "name": "JXP",
                  "type": "Object"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "urlPath"
                },
                {
                  "name": "JXP"
                }
              ]
            }
          ],
          "desc": "<p>Links assets embedded inside compiled JX file and defines them as static resource used by the application.\n\n</p>\n<p>For information, how to compile JX packages, see <a href=\"jxcore-feature-packaging-code-protection.markdown\">compile</a> command.\n\n</p>\n<p>The <code>urlPath</code> parameter is an url path, from which your application will access the asset files.\nPlease note, that it will be combined with <code>urlPath</code> provided in <code>setApplication()</code> method.\n\n</p>\n<p>The <code>JXP</code> refers to the object, which is embedded inside compiled JX file, and holds contents of JXP project file. You can access the JXP object by calling <code>exports.$JXP</code>.\n\n</p>\n<p>Let&#39;s assume, that your JXP file contains asset definition:\n\n</p>\n<pre><code class=\"js\">{\n    ...\n    ...\n    &quot;assets&quot;: [\n       &quot;README.txt&quot;,\n       &quot;Licence.txt&quot;\n    ],\n    ...\n}</code></pre>\n<p>Then you can link them to your application in a runtime:\n\n</p>\n<pre><code class=\"js\">server.linkAssets(&quot;/files&quot;, exports.$JXP);</code></pre>\n<p>Now, we could access it for example with a browser:\n\n</p>\n<pre><code>http://host:port/chat/files/README.txt</code></pre>\n<p>Please note, that &quot;/chat&quot; part is a root path for entire application (provided in <code>setApplication()</code>), while &quot;/files&quot; part is an argument from the <code>linkAssets()</code>.\nNow, the both combine into &quot;/chat/files&quot;.\n\n</p>\n"
        },
        {
          "textRaw": "linkResource(urlPath, filePath)",
          "type": "method",
          "name": "linkResource",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`urlPath` {String} ",
                  "name": "urlPath",
                  "type": "String"
                },
                {
                  "textRaw": "`filePath` {String} ",
                  "name": "filePath",
                  "type": "String"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "urlPath"
                },
                {
                  "name": "filePath"
                }
              ]
            }
          ],
          "desc": "<p>Defines static resource file used by the application.\n\n</p>\n<p>The <code>urlPath</code> is a path, from which your application will access the resource file. Please note, that it will be combined with <code>urlPath</code> provided in <code>setApplication()</code> method.\n\n</p>\n<p>The <code>filePath</code> is server&#39;s filesystem path (relative or absolute) to the resource file.\n\n</p>\n<pre><code class=\"js\">server.linkResource(&quot;/app&quot;, [&quot;./index.html&quot;, &quot;text/html&quot; ]);</code></pre>\n<p>Now, we could access it for example with a browser:\n\n</p>\n<pre><code>http://host:port/chat/app</code></pre>\n<p>Please note, that &quot;/chat&quot; part is a root path for entire application (provided in <code>setApplication()</code>), while &quot;/app&quot; part is an argument from the <code>linkResource()</code>.\nNow, the both combine into &quot;/chat/app&quot;.\n\n</p>\n"
        },
        {
          "textRaw": "linkResourcesFromPath(url, dir)",
          "type": "method",
          "name": "linkResourcesFromPath",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`url` {String} ",
                  "name": "url",
                  "type": "String"
                },
                {
                  "textRaw": "`dir` {String} ",
                  "name": "dir",
                  "type": "String"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "url"
                },
                {
                  "name": "dir"
                }
              ]
            }
          ],
          "desc": "<p>Allows linking multiple resources recursively from a given directory.\n\n</p>\n<p>Adding the whole ./assets directory (relative path from JXM.io server&#39;s working directory).\n\n</p>\n<pre><code class=\"js\">server.linkResourcesFromPath(&quot;/assets/&quot;, &quot;./assets/&quot;);</code></pre>\n<p>Now, we could access it for example with a browser:\n\n</p>\n<pre><code>http://host:port/chat/assets</code></pre>\n<p>Please note, that &quot;/chat&quot; part is a root path for entire application (provided in <code>setApplication()</code>), while &quot;/assets&quot; part is an argument from the <code>linkResourcesFromPath()</code>.\nNow, the both combine into &quot;/chat/assets&quot;.\n\n</p>\n"
        },
        {
          "textRaw": "sendCallBack(env, params)",
          "type": "method",
          "name": "sendCallBack",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`env` {Object} ",
                  "name": "env",
                  "type": "Object"
                },
                {
                  "textRaw": "`params` {Object} ",
                  "name": "params",
                  "type": "Object"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "env"
                },
                {
                  "name": "params"
                }
              ]
            }
          ],
          "desc": "<p>Calls the callback method at specific client. The <code>env</code> is the same parameter, which you received as argument for a custom method defined by you with <code>addJSMethod()</code>,\nwhile <code>params</code> is an argument for the callback. It can be anything – string, number or json literal object containing many values.\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;serverMethod&quot;, function (env, params) {\n    // server responses to a client by calling it&#39;s callback\n    server.sendCallBack(env, params + &quot; World!&quot;);\n});</code></pre>\n"
        },
        {
          "textRaw": "sendToGroup(groupName, methodName, params)",
          "type": "method",
          "name": "sendToGroup",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`params` {Object} ",
                  "name": "params",
                  "type": "Object"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "methodName"
                },
                {
                  "name": "params"
                }
              ]
            }
          ],
          "desc": "<p>Sends message to a group of subscribers, currently connected to the application. The <code>methodName</code> is the name of the method invoked on the client&#39;s side (every subscriber of this group should has this method defined), while <code>params</code> is an argument for that method.\n\n</p>\n<p>Server can send message to group of subscribers, but they need to subscribe first. See <code>Subscribe()</code>.\n\n</p>\n<p>In the code below, whenever client will call server&#39;s <code>sendFromServer()</code> method with &quot;Hello&quot; as params argument, the server for each client subscribed to <em>programmers</em> channel, will invoke his <code>clientCustomMethod()</code> passing there &quot;Hello World!&quot; string.\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;sendFromServer&quot;, function (env, params) {\n    server.sendToGroup(&quot;programmers&quot;, &quot;clientCustomMethod&quot;, params + &quot;World!&quot;);\n});</code></pre>\n"
        },
        {
          "textRaw": "setApplication(applicationName, urlPath, secretKey)",
          "type": "method",
          "name": "setApplication",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`applicationName` {String} ",
                  "name": "applicationName",
                  "type": "String"
                },
                {
                  "textRaw": "`urlPath` {String} ",
                  "name": "urlPath",
                  "type": "String"
                },
                {
                  "textRaw": "`secretKey` {String} ",
                  "name": "secretKey",
                  "type": "String"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "applicationName"
                },
                {
                  "name": "urlPath"
                },
                {
                  "name": "secretKey"
                }
              ]
            }
          ],
          "desc": "<p>Defines new application with specified <code>applicationName</code> and default root <code>urlPath</code>. Every assets or resources added to this application will start from this path.\n\n</p>\n<p>The <code>secretKey</code> parameter is for encrypting the client locator and can be obtained from JXM.io control panel.\n\n</p>\n<p>Server-side (<em>my_server.js</em>):\n\n</p>\n<pre><code class=\"js\">server.setApplication(&quot;ChatSample&quot;, &quot;/chat&quot;, &quot;NUBISA-STANDARD-KEY-CHANGE-THIS&quot;);</code></pre>\n<p>Client-side (<em>index.html</em>):\n\n</p>\n<pre><code class=\"html\">&lt;script src=&quot;/chat/jx?ms=connect&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre>\n<p>Please note, that the &quot;/chat&quot; part in the url is the <code>urlPath</code> parameter described above.\n\n</p>\n"
        },
        {
          "textRaw": "setConfig(key, value)",
          "type": "method",
          "name": "setConfig",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`key` {String} ",
                  "name": "key",
                  "type": "String"
                },
                {
                  "textRaw": "`value` {String} ",
                  "name": "value",
                  "type": "String"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "key"
                },
                {
                  "name": "value"
                }
              ]
            }
          ],
          "desc": "<p>Defines value for application’s parameter. Allows changing server configuration.\nSee <a href=\"#configuration\">Configuration</a> for detailed information.\n\n</p>\n"
        },
        {
          "textRaw": "sendToAll(methodName, params)",
          "type": "method",
          "name": "sendToAll",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`params` {Object} ",
                  "name": "params",
                  "type": "Object"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "methodName"
                },
                {
                  "name": "params"
                }
              ]
            }
          ],
          "desc": "<p>Send message to all of the clients connected currently to the application.\n\n</p>\n"
        },
        {
          "textRaw": "setEngine(app)",
          "type": "method",
          "name": "setEngine",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`app` {Object} ",
                  "name": "app",
                  "type": "Object"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "app"
                }
              ]
            }
          ],
          "desc": "<p>Defines the server engine (like express)...\n\n</p>\n"
        },
        {
          "textRaw": "start(options)",
          "type": "method",
          "name": "start",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`options` {Object} ",
                  "name": "options",
                  "type": "Object"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ],
          "desc": "<p>Starts JXM.io application with optional <code>options</code> for the server. Once started, it will be accessible to all clients.\n\n</p>\n"
        },
        {
          "textRaw": "subscribeClient(env, groupName)",
          "type": "method",
          "name": "subscribeClient",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`env` {Object} - see [Object: `env`](#object-env) ",
                  "name": "env",
                  "type": "Object",
                  "desc": "see [Object: `env`](#object-env)"
                },
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "env"
                },
                {
                  "name": "groupName"
                }
              ]
            }
          ],
          "desc": "<p>Subscribes the client to a <code>groupName</code>, or channel. This is the server-side equivalent of <code>Subscribe()</code> method from client&#39;s API.\n\n</p>\n<p>From now on, messages sent to that group by any other subscriber or server will be received by the client.\nAlso, the client can send the messages to this group – see <code>SendToGroup()</code> method.\n\n</p>\n<p>This method should be used in one of server&#39;s custom method defined with <code>addJSMethod()</code>,\nbecause it requires the <a href=\"#object-env\"><code>env</code></a> object containing information about client&#39;s call.\n\n</p>\n<p>For example, when client calls:\n\n</p>\n<pre><code class=\"js\">    jxcore.Call(&quot;someMethod&quot;, true);</code></pre>\n<p>on the server-side you can use it to subscribe him to a group:\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;someMethod&quot;, function(env, param) {\n    if (param === true) {\n        server.subscribeClient(env, &quot;testGroup&quot;);\n    }\n});</code></pre>\n<p>Of course you may apply any logic or algorithm for making the decision, whether to subscribe the client or how to allow the subscription to occur.\n\n</p>\n"
        },
        {
          "textRaw": "unSubscribeClient(env, groupName)",
          "type": "method",
          "name": "unSubscribeClient",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`env` {Object} - see [Object: `env`](#object-env) ",
                  "name": "env",
                  "type": "Object",
                  "desc": "see [Object: `env`](#object-env)"
                },
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "env"
                },
                {
                  "name": "groupName"
                }
              ]
            }
          ],
          "desc": "<p>Unsubscribes the client from a <code>groupName</code>, or channel. This is the server-side equivalent of <code>Unsubscribe()</code> method from client&#39;s API.\n\n</p>\n<p>From now on, messages sent to that group cannot be received by this client.\nAlso, the client cannot send messages to that group.\n\n</p>\n<p>The usage is analogous to the <code>subscribeClient()</code> method.\n\n</p>\n<p>client-side:\n\n</p>\n<pre><code class=\"js\">    jxcore.Call(&quot;someMethod&quot;, false);</code></pre>\n<p>server-side:\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;someMethod&quot;, function(env, param) {\n    if (param === true) {\n        server.subscribeClient(env, &quot;testGroup&quot;);\n    } else {\n        server.unSubscribeClient(env, &quot;testGroup&quot;);\n    }\n});</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "API Server"
    },
    {
      "textRaw": "API JavaScript Client",
      "name": "api_javascript_client",
      "modules": [
        {
          "textRaw": "Events",
          "name": "events",
          "properties": [
            {
              "textRaw": "document.onjxready",
              "name": "onjxready",
              "desc": "<p>There is a special event <code>document.onjxready</code>, which is called right after the JXcore script is loaded:\n\n</p>\n<pre><code class=\"html\">&lt;script src=&quot;/helloworld/jx?ms=connect&quot; type=&quot;text/javascript&quot;&gt;</code></pre>\n<p>Inside that event we can start to use jxcore object and for example we attach to the following events: <code>OnClose</code>, <code>OnError</code> and <code>Start()</code> method. The last one is the most important one for us. Please see the comments in the code above to catch the idea.\n\n</p>\n<pre><code class=\"js\">&lt;script type=&quot;text/javascript&quot;&gt;\n\n    document.onjxready = function () {\n\n        jxcore.Start(function (status) {\n\n            var send_button = document.getElementById(&#39;send_button&#39;);\n            // let&#39;s enable button, right now the script is loaded\n            send_button.disabled = &quot;&quot;;\n\n            var msg = document.getElementById(&#39;msg&#39;);\n            msg.innerHTML += &quot;Connected.&lt;BR&gt;&quot;;\n\n            var callback = function (s) {\n                msg.innerHTML += s + &quot;&lt;BR&gt;&quot;;\n            };\n\n            send_button.onclick = function () {\n                // let&#39;s call the server-side method &quot;serverMethod&quot; from the client!\n                // in turn, as a response, the backend service will invoke\n                // client&#39;s local &quot;callback&quot; defined above!\n                jxcore.Call(&quot;serverMethod&quot;, &quot;Hello&quot;, callback);\n            };\n        });\n\n        jxcore.OnClose = function (reconnecting) {\n            msg.innerHTML += &quot;Disconnected.&lt;BR&gt;&quot;;\n        };\n\n        jxcore.OnError = function (err) {\n            msg.innerHTML += err;\n        }\n    };\n&lt;/script&gt;</code></pre>\n"
            }
          ],
          "modules": [
            {
              "textRaw": "OnClose",
              "name": "onclose",
              "desc": "<p>This event is fired every time, when the client loses connection with the server.\nThe <code>reconnecting</code> parameter has a <code>true</code> value, if client already tries to reconnect.\n\n</p>\n<pre><code class=\"js\">jxcore.OnClose = function (reconnecting) {\n    msg.innerHTML += &quot;Disconnected.&lt;BR&gt;&quot;;\n};</code></pre>\n",
              "type": "module",
              "displayName": "OnClose"
            },
            {
              "textRaw": "OnError",
              "name": "onerror",
              "desc": "<p>This event is emitted every time, the error occurs.\n\n</p>\n<pre><code class=\"js\">jxcore.OnError = function (err) {\n    msg.innerHTML += err;\n}</code></pre>\n",
              "type": "module",
              "displayName": "OnError"
            },
            {
              "textRaw": "OnSubscription",
              "name": "onsubscription",
              "desc": "<p>This event is raised when client gets subscribed to a group or unsubscribes from it by a call made from a server-side (<code>subscribeClient()</code> or <code>unSubscribeClient()</code> methods).\n\n</p>\n<p>The <code>subscribed</code> value indicates whether this event was raised as a result of subscription (<code>true</code>) or unsubscription (<code>false</code>) request.\nThe <code>groupName</code> is the name of the group, for which the event occurred.\n\n</p>\n<p>When subscription/un-subscription request is made by a client&#39;s method <code>Subscribe()</code> or <code>Unsubscribe()</code>,\nthe event <code>OnSubscription</code> is not raised, but instead you may provide the callback for those methods.\nPlease refer to their description for more details.\n\n</p>\n<p>client-side:\n\n</p>\n<pre><code class=\"js\">jxcore.Call(&quot;someMethod&quot;, true);\n\njxcore.OnSubscription = function (subscribed,  group) {\n    if (subscribed) {\n        alert(&quot;event: subscribed to a group &quot; + group);\n    } else {\n        alert(&quot;event: unsubscribed from a group &quot; + group);\n    }\n};</code></pre>\n<p>server-side:\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;someMethod&quot;, function(env, param) {\n    if (param === true) {\n        server.subscribeClient(env, &quot;testGroup&quot;);\n    }\n});</code></pre>\n",
              "type": "module",
              "displayName": "OnSubscription"
            }
          ],
          "type": "module",
          "displayName": "Events"
        }
      ],
      "methods": [
        {
          "textRaw": "Call(methodName, json, callback)",
          "type": "method",
          "name": "Call",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`json` {Object} ",
                  "name": "json",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`param` {Object} ",
                      "name": "param",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "methodName"
                },
                {
                  "name": "json"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Invokes specific custom method named <code>methodName</code> defined on the server-side and passes to it one parameter <code>json</code>.\nThe client&#39;s <code>callback</code> is optional, but when provided, it will be called after server completes invoking the method\nand will receive <code>param</code> argument sent from the server-side.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<p>In the example below we call the server-side method &quot;serverMethod&quot; from the client-side.\nIn turn, as a response, the backend service will invoke the client&#39;s local <code>callback</code> function:\n\n</p>\n<pre><code class=\"js\">var callback = function(param, err) {\n    alert(param);\n}\n\njxcore.Call(&quot;serverMethod&quot;, &quot;hello&quot;, callback);</code></pre>\n<p>or simply:\n\n</p>\n<pre><code class=\"js\">jxcore.Call(&quot;serverMethod&quot;, &quot;hello&quot;, function(param, err) {\n    alert(err ? &quot;Error code: &quot; + err : param);\n});</code></pre>\n"
        },
        {
          "textRaw": "Close(silent)",
          "type": "method",
          "name": "Close",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`silent` {Boolean} ",
                  "name": "silent",
                  "type": "Boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "silent"
                }
              ]
            }
          ],
          "desc": "<p>Closes client and disconnects from the server.\n\n</p>\n<p>The <code>silent</code> parameter is optional.\nIf <code>true</code> - then <code>OnClose</code> event will not get invoked, otherwise the <code>OnClose</code> event will also be invoked with <code>false</code> value as an argument: <code>OnClose(false)</code>.\n\n</p>\n"
        },
        {
          "textRaw": "GetClientId()",
          "type": "method",
          "name": "GetClientId",
          "desc": "<p>Gets the id of the client, which is an unique string value.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ReConnect()",
          "type": "method",
          "name": "ReConnect",
          "desc": "<p>Forces the client to reconnect to the server.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "SendToGroup(groupName, methodName, json, callback)",
          "type": "method",
          "name": "SendToGroup",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`json` {Object} ",
                  "name": "json",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "methodName"
                },
                {
                  "name": "json"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Sends message to all of the clients, that have already subscribed to the specific <code>groupName</code>.\nThe message is passed as <code>json</code> argument to the target&#39;s method named <code>methodName</code>.\nThe message can be any value, primitive (string, number, etc.) or json literal object.\n\n</p>\n<p>The <code>callback</code> is optional, but when provided, it will be called after server sends the message to other clients.\nPlease note, that this is not a confirmation, whether the clients have received the message or not.\nIt just informs that the server processed the message with success or failure.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<pre><code class=\"js\">document.getElementById(&quot;btnSend&quot;).onclick = function(){\n    jxcore.SendToGroup(&quot;programmers&quot;, &quot;addText&quot;, { obj : &quot;value&quot; }, function(err) {\n        if (!err) {\n            alert(&quot;Message sent!&quot;);\n        }\n    });\n};</code></pre>\n<p>The &quot;addText&quot; method should be available on every client which is subscribed to &quot;programmers&quot; group.\nWhile invoking the &quot;addText&quot; method at each client, the server will pass { obj : &quot;value&quot; } as an argument.\n\n</p>\n"
        },
        {
          "textRaw": "Start(callback)",
          "type": "method",
          "name": "Start",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`status` {Boolean} ",
                      "name": "status",
                      "type": "Boolean"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Starts JXM.io client. Connects to the server, and when it succeeds - the client’s callback <code>callback</code> is called.\n\n</p>\n<pre><code class=\"js\">document.onjxready = function () {\n    jxcore.Start(function (status) {\n\n        // here we are, after the client has connected to server\n        // we can enable the button now\n        var btnSend = document.getElementById(&#39;btnSend&#39;);\n        btnSend.disabled = &quot;&quot;;\n\n        // do anything else\n        // see tutorials for more usage\n    });\n};</code></pre>\n"
        },
        {
          "textRaw": "Subscribe(groupName, callback)",
          "type": "method",
          "name": "Subscribe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`groupName` {String} ",
                      "name": "groupName",
                      "type": "String"
                    },
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Subscribes the client to a <code>groupName</code>, or channel. From now on, messages sent to that group by any other subscriber will be received by the client.\nAlso the client can send messages to this group – see <code>SendToGroup()</code> method.\nAfter the server successfully subscribes the client to the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<pre><code class=\"js\">jxcore.Subscribe(&quot;programmers&quot;, function (groupName, err) {\n    if (err) {\n        alert(&quot;Error while subscribing. Code: &quot; + err);\n    } else {\n        alert(&quot;subscribed to group: &quot; + groupName);\n    }\n});</code></pre>\n"
        },
        {
          "textRaw": "Unsubscribe(groupName, callback)",
          "type": "method",
          "name": "Unsubscribe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`groupName` {String} ",
                      "name": "groupName",
                      "type": "String"
                    },
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Unsubscribes the client from a <code>groupName</code>, or channel. From now on, messages sent to that group cannot be received by this client.\nAfter the server successfully unsubscribes the client from the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<pre><code class=\"js\">jxcore.Unsubscribe(&quot;programmers&quot;, function(groupName, err) {\n    if (err) {\n        alert(&quot;Error while un-subscribing. Code: &quot; + err);\n    } else {\n        alert(&quot;unsubscribed from a group: &quot; + groupName);\n    }\n});</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "API JavaScript Client"
    },
    {
      "textRaw": "API Java Client",
      "name": "api_java_client",
      "desc": "<p>There are some <a href=\"http://jxm.io\">tutorials</a> available, and they show how to consume JXM.io server from a Java Client.\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Events",
          "name": "events",
          "desc": "<p>Messaging module for Java defines events in a separate class <code>ClientEvents</code>.\nIn order to listen for client&#39;s events, we need to instantiate this class and assign to <code>client.Events</code> property:\n\n</p>\n<pre><code class=\"java\">import jxm.*;\n\njxm.ClientEvents events = new ClientEvents(){\n    @Override\n    public void OnError(Client c, String Message) {\n        // Error received\n    }\n    @Override\n    public void OnConnect(Client c) {\n        // Client is connected\n    }\n    @Override\n    public void OnClose(Client c) {\n        // Client is disconnected\n    }\n    @Override\n    public void OnEventLog(Client c, String log, LogLevel level) {\n        // get the event log from here\n    }\n    @Override\n    public void OnSubscription(Client c, Boolean subscribed, String group) {\n        // Client was subscribed to a group or unsubscribed from a group\n        // by a server-side call\n    }\n};\n//now we may define this listener into our Client instance\nclient.Events = event;</code></pre>\n",
          "modules": [
            {
              "textRaw": "OnError",
              "name": "onerror",
              "desc": "<p>This event is emitted whenever an error occurs at the <code>client</code>.\n\n</p>\n",
              "type": "module",
              "displayName": "OnError"
            },
            {
              "textRaw": "OnConnect",
              "name": "onconnect",
              "desc": "<p>This event is emitted after the <code>client</code> successfully connects to the server.\n\n</p>\n",
              "type": "module",
              "displayName": "OnConnect"
            },
            {
              "textRaw": "OnClose",
              "name": "onclose",
              "desc": "<p>This event is emitted when the <code>client</code> loses its connection with the server.\n\n</p>\n",
              "type": "module",
              "displayName": "OnClose"
            },
            {
              "textRaw": "OnEventLog",
              "name": "oneventlog",
              "desc": "<p>This event is fired whenever the <code>client</code> logs an information <code>log</code> message. The <code>level</code> parameter is an enumeration value and can have one of the following: <em>Informative</em> or <em>Critical</em>.\n\n</p>\n",
              "type": "module",
              "displayName": "OnEventLog"
            },
            {
              "textRaw": "OnSubscription",
              "name": "onsubscription",
              "desc": "<p>This event is raised when client gets subscribed to a group or unsubscribed from it by a call made from a server-side (<code>subscribeClient()</code> or <code>unSubscribeClient()</code> methods).\n\n</p>\n<p>The <code>subscribed</code> value indicates, whether this event was raised as a result of subscription (<code>true</code>) or unsubscription (<code>false</code>) request.\nThe <code>groupName</code> is the name of the group, for which the event occurred.\n\n</p>\n<p>When subscription/unsubscription request was made by a client&#39;s method <code>Subscribe()</code> or <code>Unsubscribe()</code>, the event <code>OnSubscription</code> is not raised, but instead you may provide the callback for those methods.\nPlease refer to their description for more details.\n\n</p>\n",
              "type": "module",
              "displayName": "OnSubscription"
            }
          ],
          "type": "module",
          "displayName": "Events"
        }
      ],
      "ctors": [
        {
          "textRaw": "new Client(localTarget, appName, appKey, url, port, secure)",
          "type": "ctor",
          "name": "Client",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`localTarget` {Object} ",
                  "name": "localTarget",
                  "type": "Object"
                },
                {
                  "textRaw": "`appName` {String} ",
                  "name": "appName",
                  "type": "String"
                },
                {
                  "textRaw": "`appKey` {String} ",
                  "name": "appKey",
                  "type": "String"
                },
                {
                  "textRaw": "`url` {String} ",
                  "name": "url",
                  "type": "String"
                },
                {
                  "textRaw": "`port` {int} ",
                  "name": "port",
                  "type": "int"
                },
                {
                  "textRaw": "`secure` {boolean} ",
                  "name": "secure",
                  "type": "boolean"
                },
                {
                  "textRaw": "`resetUID` {boolean} ",
                  "name": "resetUID",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "localTarget"
                },
                {
                  "name": "appName"
                },
                {
                  "name": "appKey"
                },
                {
                  "name": "url"
                },
                {
                  "name": "port"
                },
                {
                  "name": "secure"
                }
              ]
            }
          ],
          "desc": "<p>Creates an instance of JXM.io Java Client with specified application name <code>appName</code> and application key <code>appKey</code>.\nThe <code>url</code> parameter specifies JXM.io server URL, e.g. <em>sampledomain.com</em> or <em>120.1.2.3</em>. You can also enable SSL support with <code>secure</code> parameter.\n\n</p>\n<p>Setting <code>resetUID</code> as <code>true</code> will reset the unique instance id (session id).\n\n</p>\n<p>The first argument <code>localTarget</code> is an instance of a local class, which will be answering the calls from server.\nIn that class you will specify client methods, which will be callable by other clients or the server itself.\n\n</p>\n<pre><code class=\"java\">import jxm.*;\n\nClient client = new Client(new CustomMethods(), &quot;channels&quot;,\n    &quot;NUBISA-STANDARD-KEY-CHANGE-THIS&quot;, &quot;localhost&quot;, 8000, false, true);</code></pre>\n<p>and <em>CustomMethods</em> may look like this:\n\n</p>\n<pre><code class=\"java\">package io.jxm;\nimport jxm.Client;\n\npublic class CustomMethods {\n\n    public CustomMethods() { }\n\n    public void clientsMethod(Object response) {\n        System.out.println(&quot;Received message from the group: &quot; + response.toString());\n    }\n}</code></pre>\n<p>You may also inherit your custom method&#39;s class from JXM.io’s internal <code>CustomMethodBase</code> class,\nand this gives you for example access to the <code>super.client</code> instance of the <code>Client</code> object. For example:\n\n</p>\n<pre><code class=\"java\">package io.jxm;\n\nimport jxm.Client;\nimport jxm.CustomMethodsBase;\n\npublic class CustomMethods extends CustomMethodsBase {\n\n    public CustomMethods() { }\n\n    public void clientsMethod(Object response) {\n        System.out.println(&quot;Received message from the group: &quot; + response.toString());\n        super.client.Close();\n    }\n}</code></pre>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "Call(methodName, params, callback)",
          "type": "method",
          "name": "Call",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`params` {Object} ",
                  "name": "params",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {jxm.Callback} ",
                  "options": [
                    {
                      "textRaw": "`obj` {Object} ",
                      "name": "obj",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`err` {integer} ",
                      "name": "err",
                      "type": "integer"
                    }
                  ],
                  "name": "callback",
                  "type": "jxm.Callback"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "methodName"
                },
                {
                  "name": "params"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Invokes specific custom method <code>methodName</code> defined on the server-side and passes to it <code>params</code> value.\nThe <code>methodName</code> should also contain the class name and the namespace, e.g. <em>com.example.MyClass.MyMethod</em>.\n\n</p>\n<p>The optional parameter <code>callback</code> is the client’s function, which will be called after server completes invoking the method.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<p>In the example below we call the server-side method <em>serverMethod</em> from the client-side.\nIn turn, as a response, the backend service will invoke the client&#39;s local <code>callback</code> function:\n\n</p>\n<pre><code class=\"java\">client.Call(&quot;serverMethod&quot;, &quot;Hello&quot;, callback);</code></pre>\n"
        },
        {
          "textRaw": "Connect()",
          "type": "method",
          "name": "Connect",
          "desc": "<p>Starts the client, connects to the server. Returns a boolean value based on the result.\n\n</p>\n<pre><code class=\"java\">if (client.Connect()) {\n    System.out.println(&quot;ready!&quot;);\n}</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "GetClientId()",
          "type": "method",
          "name": "GetClientId",
          "desc": "<p>Gets the string containing unique id of the client.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "SendToGroup(String groupName, String methodName, Object params)",
          "type": "method",
          "name": "SendToGroup",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`params` {Object} ",
                  "name": "params",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {jxm.Callback} ",
                  "options": [
                    {
                      "textRaw": "`obj` {Object} ",
                      "name": "obj",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`err` {integer} ",
                      "name": "err",
                      "type": "integer"
                    }
                  ],
                  "name": "callback",
                  "type": "jxm.Callback"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "String groupName"
                },
                {
                  "name": "String methodName"
                },
                {
                  "name": "Object params"
                }
              ]
            }
          ],
          "desc": "<p>Sends message to all clients, that have already subscribed to the specific <code>groupName</code>. The message is passed as <code>params</code> argument to the target&#39;s method named <code>methodName</code>.\n\n</p>\n<p>The <code>callback</code> is optional, but when provided, it will be called after server sends the message to other clients.\nPlease note, that this is not a confirmation, whether the clients have received the message or not.\nIt just informs that the server processed the message with success or failure.\n\n</p>\n<p>The &quot;addText&quot; method should be available on every client, which is subscribed to <em>programmers</em> group.\nWhile invoking the <em>addText</em> method at each client, the server will pass &quot;Hello from client!&quot; as an argument.\n\n</p>\n<pre><code class=\"java\">client.SendToGroup(&quot;programmers&quot;, &quot;addText&quot;, &quot;Hello from client!&quot;);</code></pre>\n"
        },
        {
          "textRaw": "Subscribe(groupName, callback)",
          "type": "method",
          "name": "Subscribe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`callback` {jxm.Callback} ",
                  "options": [
                    {
                      "textRaw": "`groupName` {String} ",
                      "name": "groupName",
                      "type": "String"
                    },
                    {
                      "textRaw": "`err` {integer} ",
                      "name": "err",
                      "type": "integer"
                    }
                  ],
                  "name": "callback",
                  "type": "jxm.Callback"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Subscribes the client to a <code>groupName</code>, or channel. From now on, messages sent to that group by any other subscriber will be received by the client.\nAlso the client can send messages to this group – see <code>SendToGroup()</code> method.\n\n</p>\n<p>After the server successfully subscribes the client to the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<pre><code class=\"java\">try {\n     client.Subscribe(&quot;programmers&quot;, new Callback() {\n         @Override\n         public void call(Object o) throws Exception {\n             System.out.println(&quot;Subscribed to &quot; + o.toString());\n             client.SendToGroup(&quot;programmers&quot;, &quot;clientMethod&quot;,\n             &quot;Hello from client!&quot;);\n         }\n     });\n} catch (Exception e) {\n     System.out.println(&quot;Cannot subscribe.&quot;);\n}</code></pre>\n"
        },
        {
          "textRaw": "Unsubscribe(group, callback)",
          "type": "method",
          "name": "Unsubscribe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`callback` {jxm.Callback} ",
                  "options": [
                    {
                      "textRaw": "`groupName` {String} ",
                      "name": "groupName",
                      "type": "String"
                    },
                    {
                      "textRaw": "`err` {integer} ",
                      "name": "err",
                      "type": "integer"
                    }
                  ],
                  "name": "callback",
                  "type": "jxm.Callback"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "group"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Unsubscribes the client from a <code>groupName</code>, or channel. From now on, messages sent to that group cannot be received by this client.\n\n</p>\n<p>After the server successfully unsubscribes the client from the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<pre><code class=\"java\">try {\n     client.Unsubscribe(&quot;programmers&quot;, new Callback() {\n         @Override\n         public void call(Object o) throws Exception {\n             System.out.println(&quot;Unsubscribed from &quot; + o.toString());\n         }\n     });\n} catch (Exception e) {\n     System.out.println(&quot;Cannot unsubscribe.&quot;);\n}</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "API Java Client"
    },
    {
      "textRaw": "API JXcore / Node.JS Client",
      "name": "api_jxcore_/_node.js_client",
      "desc": "<p>This section describes JXM.io server for JXcore or Node.JS client. It is based on API JavaScript client for browsers and is also written in JavaScript.\nBut the difference is, that JXcore / Node.JS clients do not use browsers - they can be launched from a command line, just like any other JXcore / Node.JS application.\n\n</p>\n<p>The following sample creates one JXM.io server and client in one script file:\n\n</p>\n<pre><code class=\"js\">// -------------   server\n\nvar server = require(&quot;./messaging.jx&quot;);\nserver.setApplication(&quot;TestApp&quot;, &quot;/test&quot;, &quot;myKey&quot;);\n\nserver.addJSMethod(&quot;server_method&quot;, function (env, param) {\n    server.sendCallBack(env, &quot;Hello back!&quot;);\n    server.sendToAll(&quot;client_method&quot;, &quot;Message sent to all.&quot;);\n});\n\n\nserver.setConfig({ &quot;IPAddress&quot;: &quot;localhost&quot;, &quot;httpServerPort&quot;: 8000 });\nserver.start();\n\n// -------------   client\n\n// client&#39;s custom methods.\n// this is the way to receive messages from sendToGroup() or sendToAll()\nvar methods = {\n    client_method: function (client, str) {\n        console.log(&#39;Received message from sendToGroup() or sendToll():&#39;, str);\n    }\n};\n\nvar client = server.createClient(methods, &quot;test&quot;, &quot;myKey&quot;, &quot;localhost&quot;, 8000, false);\n\nclient.on(&quot;connect&quot;, function (client) {\n    console.log(&quot;Client connected.&quot;);\n    client.Call(&quot;server_method&quot;, &quot;Hello&quot;, function (param, err) {\n        if (!err) {\n            console.log(&quot;Client received callback with message&quot;, param);\n        }\n    });\n});\n\nclient.on(&#39;error&#39;, function (client, err) {\n    console.error(&quot;Client error: &quot; + err);\n});\n\nclient.Connect();</code></pre>\n",
      "modules": [
        {
          "textRaw": "Events",
          "name": "events",
          "modules": [
            {
              "textRaw": "connect",
              "name": "connect",
              "desc": "<p>This event occurs each time a client connects to the server (also when reconnects)\n\n</p>\n<pre><code class=\"js\">client.on(&quot;connect&quot;, function (client) {\n    console.log(&quot;Client connected.&quot;)\n});</code></pre>\n",
              "type": "module",
              "displayName": "connect"
            },
            {
              "textRaw": "close",
              "name": "close",
              "desc": "<p>This event is fired every time a client loses connection with the server.\nThe <code>reconnecting</code> parameter has a <code>true</code> value, if a client already tries to reconnect.\n\n</p>\n<pre><code class=\"js\">client.on(&quot;close&quot;, function (client, reconnecting) {\n    console.log(&quot;Client disconnected. Reconnecting ?&quot;, reconnecting);\n});</code></pre>\n",
              "type": "module",
              "displayName": "close"
            },
            {
              "textRaw": "error",
              "name": "error",
              "desc": "<p>This event is produced every time an error occurs.\n\n</p>\n<pre><code class=\"js\">client.on(&#39;error&#39;, function (client, err) {\n    console.error(&quot;Client error: &quot; + err);\n});</code></pre>\n",
              "type": "module",
              "displayName": "error"
            },
            {
              "textRaw": "subscription",
              "name": "subscription",
              "desc": "<p>This event is raised when a client gets subscribed to a group or unsubscribed from it by a call made from a server-side code\n(<code>subscribeClient()</code> or <code>unSubscribeClient()</code> methods).\n\n</p>\n<p>The <code>subscribed</code> value indicates whether this event was raised as a result of a subscription (<code>true</code>) or un-subscription (<code>false</code>) request.\nThe <code>groupName</code> is the name of the group, for which the event occurred.\n\n</p>\n<p>When subscription/un-subscription request is made by a client&#39;s method <code>Subscribe()</code> or <code>Unsubscribe()</code>,\nthe event <code>OnSubscription</code> is not raised, but instead you can provide the callback for those methods.\nPlease refer to their description for more details.\n\n</p>\n<p>client-side:\n\n</p>\n<pre><code class=\"js\">client.on(&quot;connect&quot;, function (client) {\n    // this invokes server&#39;s method\n    client.Call(&quot;server_method&quot;, null);\n});\n\nclient.on(&#39;subscription&#39;, function (client, subscribed, group) {\n    var status = subscribed ? &quot;subscribed&quot; : &quot;unsubscribed&quot;;\n    console.log(&quot;client&quot;, status, &quot;to a group&quot;, group);\n});</code></pre>\n<p>server-side:\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;server_method&quot;, function (env, params) {\n    server.subscribeClient(env, groupName);\n});</code></pre>\n",
              "type": "module",
              "displayName": "subscription"
            }
          ],
          "type": "module",
          "displayName": "Events"
        }
      ],
      "ctors": [
        {
          "textRaw": "new Client(localTarget, appName, appKey, url, port, secure)",
          "type": "ctor",
          "name": "Client",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`localTarget` {Object} ",
                  "name": "localTarget",
                  "type": "Object"
                },
                {
                  "textRaw": "`appName` {String} ",
                  "name": "appName",
                  "type": "String"
                },
                {
                  "textRaw": "`appKey` {String} ",
                  "name": "appKey",
                  "type": "String"
                },
                {
                  "textRaw": "`url` {String} ",
                  "name": "url",
                  "type": "String"
                },
                {
                  "textRaw": "`port` {int} ",
                  "name": "port",
                  "type": "int"
                },
                {
                  "textRaw": "`secure` {boolean} ",
                  "name": "secure",
                  "type": "boolean"
                },
                {
                  "textRaw": "`resetUID` {boolean} ",
                  "name": "resetUID",
                  "type": "boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "localTarget"
                },
                {
                  "name": "appName"
                },
                {
                  "name": "appKey"
                },
                {
                  "name": "url"
                },
                {
                  "name": "port"
                },
                {
                  "name": "secure"
                }
              ]
            }
          ],
          "desc": "<p>Creates an instance of the client with specified application name <code>appName</code> and application key <code>appKey</code>.\nThe <code>url</code> parameter specifies JXM.io server URL, e.g. <em>sampledomain.com</em> or <em>120.1.2.3</em>.\nYou can also enable SSL support with <code>secure</code> parameter.\n\n</p>\n<p>The first argument <code>localTarget</code> is an object containing custom methods, which will be answering the calls from server.\nIn that object you will define client methods, which can be called by other clients or the server itself.\n\n</p>\n<pre><code class=\"js\">// client&#39;s custom methods.\n// this is the way to receive messages from sendToGroup() or sendToAll()\nvar customMethods = {\n    client_method: function (client, str) {\n        console.log(&#39;Received message from sendToGroup() or sendToll():&#39;, str);\n    }\n};\n\nvar client = server.createClient(customMethods,\n                &quot;test&quot;, &quot;myKey&quot;, &quot;localhost&quot;, 8000, false);</code></pre>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "Call(methodName, json, callback)",
          "type": "method",
          "name": "Call",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`json` {Object} ",
                  "name": "json",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`param` {Object} ",
                      "name": "param",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "methodName"
                },
                {
                  "name": "json"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Invokes a specific custom method named <code>methodName</code> defined on the server-side and passes one parameter <code>json</code>.\nThe client&#39;s <code>callback</code> is optional, but when provided, it will be called after server completes invoking the method\nand will receive <code>param</code> argument sent from the server-side.\n\n</p>\n<p>In the example below we call the server-side method &quot;serverMethod&quot; from the client-side.\nIn turn, as a response, the backend service will invoke the client&#39;s local <code>callback</code> function.\n\n</p>\n<p>If error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<p>client-side:\n\n</p>\n<pre><code class=\"js\">client.on(&quot;connect&quot;, function (client) {\n    client.Call(&quot;server_method&quot;, &quot;Hello&quot;, function(param) {\n        console.log(&quot;Client received callback with message&quot;, param);\n    });\n});</code></pre>\n<p>server-side:\n\n</p>\n<pre><code class=\"js\">server.addJSMethod(&quot;server_method&quot;, function(env, param) {\n    server.sendCallBack(env, &quot;Hello back!&quot;);\n});</code></pre>\n"
        },
        {
          "textRaw": "Close(silent)",
          "type": "method",
          "name": "Close",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`silent` {Boolean} ",
                  "name": "silent",
                  "type": "Boolean"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "silent"
                }
              ]
            }
          ],
          "desc": "<p>Closes client and disconnects from the server.\n\n</p>\n<p>If <code>true</code> - then <code>OnClose</code> event will not get invoked, otherwise the <code>OnClose</code> event will also be invoked with <code>false</code> value as an argument: <code>OnClose(false)</code>.\n\n</p>\n"
        },
        {
          "textRaw": "Connect()",
          "type": "method",
          "name": "Connect",
          "desc": "<p>Starts JXcore / Node.JS client. Connects to the JXM.io server, and when it succeeds - the client’s event <code>on(&#39;connect&#39;)</code> will be raised.\n\n</p>\n<pre><code class=\"js\">client.on(&quot;connect&quot;, function (client) {\n    console.log(&quot;Client connected.&quot;)\n});\n\nclient.on(&#39;error&#39;, function (client, err) {\n    console.error(&quot;Client error: &quot; + err);\n});\n\nclient.Connect();</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "GetClientId()",
          "type": "method",
          "name": "GetClientId",
          "desc": "<p>Gets the id of the client, which is a unique string value.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ReConnect()",
          "type": "method",
          "name": "ReConnect",
          "desc": "<p>Forces the client to reconnect to the server.\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "SendToGroup(groupName, methodName, json)",
          "type": "method",
          "name": "SendToGroup",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`methodName` {String} ",
                  "name": "methodName",
                  "type": "String"
                },
                {
                  "textRaw": "`json` {Object} ",
                  "name": "json",
                  "type": "Object"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`param` {Object} ",
                      "name": "param",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "methodName"
                },
                {
                  "name": "json"
                }
              ]
            }
          ],
          "desc": "<p>Sends message to all of the clients, which have already subscribed to the specific <code>groupName</code>.\nThe message is passed as <code>json</code> argument to the target&#39;s method named <code>methodName</code>.\nThe message can be any value, primitive (string, number, etc.) or json literal object.\n\n</p>\n<p>The <code>callback</code> is optional, but when provided, it will be called after server sends the message to other clients.\nPlease note, that this is not a confirmation, whether the clients have received the message or not.\nIt just informs that the server processed the message with success or failure.\n\n\n</p>\n<pre><code class=\"js\">client.on(&quot;connect&quot;, function (client) {\n    client.Subscribe(groupName, function (group, err) {\n        if (!err) {\n            client.SendToGroup(&quot;programmers&quot;, &quot;client_method&quot;, { obj : &quot;value&quot; });\n        }\n    });\n});</code></pre>\n<p>The &quot;client_method&quot; method should be available on every client which is subscribed to &quot;programmers&quot; group.\nWhile invoking the &quot;client_method&quot; method at each client, the server will pass { obj : &quot;value&quot; } as an argument.\n\n</p>\n"
        },
        {
          "textRaw": "Subscribe(groupName, callback)",
          "type": "method",
          "name": "Subscribe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`groupName` {String} ",
                      "name": "groupName",
                      "type": "String"
                    },
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Subscribes the client to a <code>groupName</code>, or channel. Subsequently, messages sent to that group by any other subscriber will be received by the client.\nAlso the client can send messages to this group – see <code>SendToGroup()</code> method.\n\n</p>\n<p>After the server successfully subscribes the client to the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<pre><code class=\"js\">client.on(&quot;connect&quot;, function (client) {\n    client.Subscribe(&quot;programmers&quot;, function (group) {\n        console.log(&quot;Subscribed to a &quot; + group);\n    });\n});</code></pre>\n"
        },
        {
          "textRaw": "Unsubscribe(groupName, callback)",
          "type": "method",
          "name": "Unsubscribe",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`groupName` {String} ",
                  "name": "groupName",
                  "type": "String"
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "options": [
                    {
                      "textRaw": "`groupName` {String} ",
                      "name": "groupName",
                      "type": "String"
                    },
                    {
                      "textRaw": "`err` {Number} ",
                      "name": "err",
                      "type": "Number"
                    }
                  ],
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "groupName"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<p>Unsubscribes the client from a <code>groupName</code>, or channel. Subsequently, messages sent to that group cannot be received by this client.\n\n</p>\n<p>After the server successfully unsubscribes the client from the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.\nIf error occurs, <code>err</code> parameter will have an integer code of the error. Otherwise, it will be equal to 0 (zero). See <a href=\"#jxcore_messaging_error_codes\">error codes</a>.\n\n</p>\n<pre><code class=\"js\">client.on(&quot;connect&quot;, function (client) {\n    client.UnSubscribe(&quot;programmers&quot;, function (group) {\n        console.log(&quot;Unsubscribed from a &quot; + group);\n    });\n});</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "API JXcore / Node.JS Client"
    }
  ]
}
