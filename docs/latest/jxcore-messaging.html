<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Messaging JXcore Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
</head>
<body class="alt apidoc" id="api-section-jxcore-messaging">
    <div id="header_bar">
        <div id="logo_bar">
            <a href="http://jxcore.com/" title="Go back to the home page">
                <img id="logo" src="assets/main-logo_white.png" alt="jxcore">
            </a>
        </div>
    </div>
    <div id="content" class="clearfix">

        <div id="column2" class="interior">
            <ul>
                <li><a href="http://jxcore.com/" class="home">Home</a></li>
                <li><a href="http://jxcore.com/downloads/" class="download">Download</a></li>
                <li><a href="index.html" class="docs current">Docs</a></li>
                <li><a href="http://jxcore.com/tutorials/" class="docs current">Tutorials</a></li>
                <li><a href="https://github.com/Nubisa/jxdocs/issues/" class="about">Issues</a></li>
                <li><a href="http://jxcore.com/blog" class="blog">Blog</a></li>
            </ul>
            <p class="twitter"><a href="https://twitter.com/nodejx">Follow us</a></p>
        </div>

        <div id="column1" class="interior">
            <div class="intro_text">
                JXcore is a multithreaded Node.JS distribution with additional features.
                <br/>
                <br/>
                <strong>The Node.JS contents here is synced from Node.JS Github Repository.</strong>
            </div>
          <header>
            <h1>JXcore Manual &amp; Documentation</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Index</a> |
                <a href="all.html">View on single page</a> |
                <a href="jxcore-messaging.json">View as JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
<li><a href="#jxcore_messaging_messaging">Messaging</a></li>
<li><a href="#jxcore_messaging_api_server">API Server</a><ul>
<li><a href="#jxcore_messaging_configuration">Configuration</a><ul>
<li><a href="#jxcore_messaging_chunked">chunked</a></li>
<li><a href="#jxcore_messaging_collectorlatency">collectorLatency</a></li>
<li><a href="#jxcore_messaging_console">console</a></li>
<li><a href="#jxcore_messaging_consoleinfo">consoleInfo</a></li>
<li><a href="#jxcore_messaging_consolethreadnumber">consoleThreadNumber</a></li>
<li><a href="#jxcore_messaging_enableclientsidesubscription">enableClientSideSubscription</a></li>
<li><a href="#jxcore_messaging_encoding">encoding</a></li>
<li><a href="#jxcore_messaging_httpscertlocation">httpsCertLocation</a></li>
<li><a href="#jxcore_messaging_httpskeylocation">httpsKeyLocation</a></li>
<li><a href="#jxcore_messaging_httpserverpor">httpServerPor</a></li>
<li><a href="#jxcore_messaging_httpsserverport">httpsServerPort</a></li>
<li><a href="#jxcore_messaging_ipaddress">IPAddress</a></li>
<li><a href="#jxcore_messaging_listenertimeout">listenerTimeout</a></li>
<li><a href="#jxcore_messaging_mapiversion">mapiVersion</a></li>
</ul>
</li>
<li><a href="#jxcore_messaging_events">Events</a><ul>
<li><a href="#jxcore_messaging_subscribe">subscribe</a></li>
<li><a href="#jxcore_messaging_unsubscribe">unsubscribe</a></li>
<li><a href="#jxcore_messaging_sendtogroup">sendToGroup</a></li>
</ul>
</li>
<li><a href="#jxcore_messaging_object_env">Object: env</a></li>
<li><a href="#jxcore_messaging_allowedresourcetypes">allowedResourceTypes</a></li>
<li><a href="#jxcore_messaging_addjsmethod_name_method">addJSMethod(name, method)</a></li>
<li><a href="#jxcore_messaging_getconfig_key">getConfig(key)</a></li>
<li><a href="#jxcore_messaging_linkassets_urlpath_jxp">linkAssets(urlPath, JXP)</a></li>
<li><a href="#jxcore_messaging_linkresource_urlpath_filepath">linkResource(urlPath, filePath)</a></li>
<li><a href="#jxcore_messaging_linkresourcesfrompath_url_dir">linkResourcesFromPath(url, dir)</a></li>
<li><a href="#jxcore_messaging_sendcallback_env_params">sendCallBack(env, params)</a></li>
<li><a href="#jxcore_messaging_sendtogroup_groupname_methodname_params">sendToGroup(groupName, methodName, params)</a></li>
<li><a href="#jxcore_messaging_setapplication_applicationname_urlpath_secretkey">setApplication(applicationName, urlPath, secretKey)</a></li>
<li><a href="#jxcore_messaging_setconfig_key_value">setConfig(key, value)</a></li>
<li><a href="#jxcore_messaging_sendtoall_methodname_params">sendToAll(methodName, params)</a></li>
<li><a href="#jxcore_messaging_setengine_app">setEngine(app)</a></li>
<li><a href="#jxcore_messaging_start_options">start(options)</a></li>
<li><a href="#jxcore_messaging_subscribeclient_env_groupname">subscribeClient(env, groupName)</a></li>
<li><a href="#jxcore_messaging_unsubscribeclient_env_groupname">unSubscribeClient(env, groupName)</a></li>
</ul>
</li>
<li><a href="#jxcore_messaging_api_javascript_client">API JavaScript Client</a><ul>
<li><a href="#jxcore_messaging_events_1">Events</a><ul>
<li><a href="#jxcore_messaging_document_onjxready">document.onjxready</a></li>
<li><a href="#jxcore_messaging_onclose">OnClose</a></li>
<li><a href="#jxcore_messaging_onerror">OnError</a></li>
<li><a href="#jxcore_messaging_onsubscription">OnSubscription</a></li>
</ul>
</li>
<li><a href="#jxcore_messaging_call_methodname_json_cb">Call(methodName, json, cb)</a></li>
<li><a href="#jxcore_messaging_close_tx">Close(tx)</a></li>
<li><a href="#jxcore_messaging_getclientid">GetClientId()</a></li>
<li><a href="#jxcore_messaging_reconnect">ReConnect()</a></li>
<li><a href="#jxcore_messaging_sendtogroup_groupname_methodname_json">SendToGroup(groupName, methodName, json)</a></li>
<li><a href="#jxcore_messaging_start_cb">Start(cb)</a></li>
<li><a href="#jxcore_messaging_subscribe_groupname_callback">Subscribe(groupName, callback)</a></li>
<li><a href="#jxcore_messaging_unsubscribe_groupname_callback">Unsubscribe(groupName, callback)</a></li>
</ul>
</li>
<li><a href="#jxcore_messaging_api_java_client">API Java Client</a><ul>
<li><a href="#jxcore_messaging_events_2">Events</a><ul>
<li><a href="#jxcore_messaging_onerrorreceived">OnErrorReceived</a></li>
<li><a href="#jxcore_messaging_onclientconnected">OnClientConnected</a></li>
<li><a href="#jxcore_messaging_onclientdisconnected">OnClientDisconnected</a></li>
<li><a href="#jxcore_messaging_oneventlog">OnEventLog</a></li>
<li><a href="#jxcore_messaging_onsubscription_1">OnSubscription</a></li>
</ul>
</li>
<li><a href="#jxcore_messaging_new_client_localtarget_appname_appkey_url_port_secure">new Client(localTarget, appName, appKey, url, port, secure)</a></li>
<li><a href="#jxcore_messaging_call_methodname_params_callback">Call(methodName, params, callback)</a></li>
<li><a href="#jxcore_messaging_connect">Connect()</a></li>
<li><a href="#jxcore_messaging_getclientid_1">getClientId()</a></li>
<li><a href="#jxcore_messaging_sendtogroup_string_groupname_string_methodname_object_params">SendToGroup(String groupName, String methodName, Object params)</a></li>
<li><a href="#jxcore_messaging_subscribe_groupname_callback_1">Subscribe(groupName, callback)</a></li>
<li><a href="#jxcore_messaging_unsubscribe_group_callback">Unsubscribe(group, callback)</a></li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>Messaging<span><a class="mark" href="#jxcore_messaging_messaging" id="jxcore_messaging_messaging">#</a></span></h1>
<p>Using JXcore Messaging, your clients can easily communicate with the server (backend service) as well as with other clients.

</p>
<p>Simply create a custom method. It can be invoked either by any of the clients or by the server itself.

</p>
<p>If you want to create an online game, chat application, or any other project for multiple users – JXcore Messaging is for you.

</p>
<p>There are some tutorials for using JXcore Messaging available here: <a href="http://jxcore.com/messaging-api/#cat-32">Hello World</a>.

</p>
<h1>API Server<span><a class="mark" href="#jxcore_messaging_api_server" id="jxcore_messaging_api_server">#</a></span></h1>
<h2>Configuration<span><a class="mark" href="#jxcore_messaging_configuration" id="jxcore_messaging_configuration">#</a></span></h2>
<p>All of the server&#39;s settings listed below may be changed using <a href="#jxcore_messaging_setconfig_key_value"><code>setConfig()</code></a> method.

</p>
<h3>chunked<span><a class="mark" href="#jxcore_messaging_chunked" id="jxcore_messaging_chunked">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span> default <code>true</code></li>
</div></ul>
<p>Enables messaging server to send multiple messages at once to the client. This increases performance of JXcore Messaging.
There are some browser versions, however, which don&#39;t support this feature (for example IE below v8).
In this case, chunked mode is internally disabled, even if server&#39;s <code>chunked</code> option is set to <code>true</code>.

</p>
<h3>collectorLatency<span><a class="mark" href="#jxcore_messaging_collectorlatency" id="jxcore_messaging_collectorlatency">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Number</span> default 50</li>
</div></ul>
<p>Defines interval in milliseconds for pushing messages to the clients.
Each message, that client has sent to the server or other clients is not processed immediately.
Instead it is queued and processed together with other messages collected within <code>collectorLatency</code> period.
This way server stays more responsive, because doesn&#39;t have to deal with each message separately.

</p>
<h3>console<span><a class="mark" href="#jxcore_messaging_console" id="jxcore_messaging_console">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span> default <code>true</code></li>
</div></ul>
<p>When enabled, displays log and error messages to the console output.

</p>
<h3>consoleInfo<span><a class="mark" href="#jxcore_messaging_consoleinfo" id="jxcore_messaging_consoleinfo">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span> default <code>false</code></li>
</div></ul>
<p>When enabled, displays additional (informative) log messages to the console output.

</p>
<h3>consoleThreadNumber<span><a class="mark" href="#jxcore_messaging_consolethreadnumber" id="jxcore_messaging_consolethreadnumber">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span> default <code>true</code></li>
</div></ul>
<p>When JXcore Messaging server runs in multi-threaded mode and this option is enabled, each of log and error messages displayed to the console
contains information about thread ID, from which the message comes.

</p>
<p>Example output:

</p>
<pre><code>Thread#1 JXcore Messaging v0.22
Thread#0 JXcore Messaging v0.22
Thread#1 HTTP  -&gt; http://192.168.1.11:8000/test
Thread#0 HTTP  -&gt; http://192.168.1.11:8000/test</code></pre>
<h3>enableClientSideSubscription<span><a class="mark" href="#jxcore_messaging_enableclientsidesubscription" id="jxcore_messaging_enableclientsidesubscription">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Boolean</span> default <code>false</code></li>
</div></ul>
<p>When this option is set to <code>false</code> (and it is by default), the client&#39;s methods <code>Subscribe()</code> and <code>Unsubscribe()</code> are disabled.
They still exist in client&#39;s API, but invoking them will have no effect, since the calls will be ignored on the server-side.
Client&#39;s are still able to send messages to the groups, but since they cannot subscribe o them, it should be done by the server.
See server-side methods <a href="#jxcore_messaging_subscribeclient_env_groupname"><code>subscribeClient()</code></a> and <a href="#jxcore_messaging_unsubscribeclient_env_groupname"><code>unSubscribeClient()</code></a>.

</p>
<h3>encoding<span><a class="mark" href="#jxcore_messaging_encoding" id="jxcore_messaging_encoding">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">String</span> default &quot;UTF-8&quot;</li>
</div></ul>
<p>Defines encoding type of messages being sent both ways between server and client&#39;s.

</p>
<h3>httpsCertLocation<span><a class="mark" href="#jxcore_messaging_httpscertlocation" id="jxcore_messaging_httpscertlocation">#</a></span></h3>
<h3>httpsKeyLocation<span><a class="mark" href="#jxcore_messaging_httpskeylocation" id="jxcore_messaging_httpskeylocation">#</a></span></h3>
<ul>
<li>{String} default null</li>
</ul>
<p>Those both options define locations for SSL certificate files. See also: <code>httpsServerPort</code> option.

</p>
<h3>httpServerPor<span><a class="mark" href="#jxcore_messaging_httpserverpor" id="jxcore_messaging_httpserverpor">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Number</span> default 8000</li>
</div></ul>
<p>Defines port for HTTP server of JXcore Messaging Server.

</p>
<h3>httpsServerPort<span><a class="mark" href="#jxcore_messaging_httpsserverport" id="jxcore_messaging_httpsserverport">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Number</span> default 0</li>
</div></ul>
<p>Defines port for HTTPS (SSL) server of JXcore Messaging.
The default value 0 also disables SSL support and it means, that JXcore Messaging backend will run based on regular HTTP protocol.
When <code>httpsServerPort</code> is set to a number, both <code>httpsCertLocation</code> and <code>httpsKeyLocation</code> should be provided and be a valid file paths,
otherwise SSL support will not be enabled.

</p>
<h3>IPAddress<span><a class="mark" href="#jxcore_messaging_ipaddress" id="jxcore_messaging_ipaddress">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">String</span> default &quot;localhost&quot;;</li>
</div></ul>
<p>Defines the IP address, on which JXcore Messaging backend&#39;s HTTP or HTTPS server will be running.
By default it&#39;s &quot;localhost&quot;, but you may also use any valid IP address, like &quot;192.168.1.11&quot; or any other.

</p>
<p>Client&#39;s will use this value to connect to the server, so the IP should be always accessible for them.
For example, you should avoid situations in which JXcore Messaging server is configured for IP set to &quot;localhost&quot; or &quot;127.0.0.1&quot;,
but client&#39;s are connecting from remote machines using server&#39;s public address.
Although this might work, and client&#39;s might connect it might also generate errors.
For example some browsers may fail to use WebSockets and will try to switch to older HTTP protocols.

</p>
<h3>listenerTimeout<span><a class="mark" href="#jxcore_messaging_listenertimeout" id="jxcore_messaging_listenertimeout">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">Number</span> default 60000</li>
</div></ul>
<p>Defines long polling request time in milliseconds. The maximum value is should not be greater that 120000 (120 seconds).

</p>
<h3>mapiVersion<span><a class="mark" href="#jxcore_messaging_mapiversion" id="jxcore_messaging_mapiversion">#</a></span></h3>
<div class="signature"><ul>
<li><span class="type">String</span></li>
</div></ul>
<p>Contains version number of JXcore Messaging Server. For example &quot;0.22&quot;.
It is used mostly for informational purpose and is displayed for example when server starts from tthe console window.

</p>
<h2>Events<span><a class="mark" href="#jxcore_messaging_events" id="jxcore_messaging_events">#</a></span></h2>
<h3>subscribe<span><a class="mark" href="#jxcore_messaging_subscribe" id="jxcore_messaging_subscribe">#</a></span></h3>
<ul>
<li><code>env</code> {Object} - see <a href="#jxcore_messaging_object_env">Object: <code>env</code></a></li>
<li><code>params</code> {Object}<ul>
<li><code>req</code> {Object} - object containing information about client&#39;s request</li>
<li><code>group</code> {String} - name of the group, to which user subscribes</li>
<li><code>groups</code> {Array} - names of the groups, to which user already belongs</li>
</ul>
</li>
<li><code>allow</code> {Function}</li>
</ul>
<p>Condition for this event to be fired is that server-side <a href="#jxcore_messaging_enableclientsidesubscription"><code>enableClientSideSubscription</code></a> option should enabled.
By default it is set to false, and it means, that client&#39;s cannot subscribe to a channels nor unsubscribe from them.
In that case the event <code>subscribe</code> is never raised.

</p>
<p>When <code>enableClientSideSubscription</code> is set to true, the <code>subscribe</code> event fires whenever client subscribes to a <code>group</code> by calling its <code>Subscribe()</code> method.
If no listener is attached to this event, user subscribes always.

</p>
<p>Attaching to this event gives you control, whether to allow the user to be subscribed or not.
The <code>allow</code> argument is a function, which should be called if you want to accept user&#39;s subscription request.
Otherwise user will not be subscribed to a <code>group</code>, and client&#39;s callback will not be invoked.

</p>
<p>client-side (index.html):

</p>
<pre><code class="js">var callback = function(group) {
    alert(&quot;subscribed to &quot; + group);
};

jxcore.Subscribe(&quot;group1&quot;, callback);</code></pre>
<p>server-side (my_server.js):
</p>
<pre><code class="js">server.on(&quot;subscribe&quot;, function(env, params, allow) {
    // don&#39;t ever subscribe to &quot;admin_group&quot;
    if (params.group !== &quot;admin_group&quot;) {
        allow();
    }
});</code></pre>
<h3>unsubscribe<span><a class="mark" href="#jxcore_messaging_unsubscribe" id="jxcore_messaging_unsubscribe">#</a></span></h3>
<div class="signature"><ul>
<li><code>env</code> <span class="type">Object</span> - see <a href="#jxcore_messaging_object_env">Object: <code>env</code></a></li>
<li><code>params</code> <span class="type">Object</span><ul>
<li><code>req</code> <span class="type">Object</span></li>
<li><code>group</code> <span class="type">String</span></li>
<li><code>groups</code> <span class="type">Array</span></li>
</ul>
</li>
<li><code>allow</code> <span class="type">Function</span></li>
</div></ul>
<p>Condition for this event to be fired is that server-side <a href="#jxcore_messaging_enableclientsidesubscription"><code>enableClientSideSubscription</code></a> option should enabled.
By default it is set to false, and it means, that client&#39;s cannot subscribe to a channels nor unsubscribe from them.
In that case the event <code>subscribe</code> is never raised.

</p>
<p>When <code>enableClientSideSubscription</code> is set to true, the <code>unsubscribe</code> event fires whenever client unsubscribes from a <code>group</code> by calling its <code>Unsubscribe()</code> method.
If no listener is attached to this event, user unsubscribes always.

</p>
<p>Attaching to this event gives you control, whether to allow the user to be unsubscribed or not.

</p>
<p>See also: <a href="#jxcore_messaging_event_subscribe">Event: &#39;subscribe&#39;</a>

</p>
<h3>sendToGroup<span><a class="mark" href="#jxcore_messaging_sendtogroup" id="jxcore_messaging_sendtogroup">#</a></span></h3>
<div class="signature"><ul>
<li><code>env</code> <span class="type">Object</span> - see <a href="#jxcore_messaging_object_env">Object: <code>env</code></a></li>
<li><code>params</code> <span class="type">Object</span><ul>
<li><code>req</code> <span class="type">Object</span> - object containing information about client&#39;s request</li>
<li><code>group</code> <span class="type">String</span> - group, to which client is sending a message</li>
<li><code>method</code> <span class="type">Array</span> - name of the method called by a client with <code>SendToGroup()</code></li>
<li><code>message</code> <span class="type">Object</span> - contents of a message</li>
</ul>
</li>
<li><code>allow</code> <span class="type">Function</span></li>
</div></ul>
<p>This event fires, whenever user calls <code>SendToGroup()</code> method.
If no listener is attached to this event, messages are always sent.

</p>
<p>Attaching to this event gives you control, whether to allow for sending particular message or not.

</p>
<p>The <code>allow</code> argument is a function, which should be called if you want to let the message to be sent.

</p>
<p>client-side (index.html):

</p>
<pre><code class="js">    btnSend.onclick = function() {
        jxcore.SendToGroup(&#39;group1&#39;, &quot;clientsMethod&quot;, { txt: &quot;my_message&quot;} );
    };</code></pre>
<p>server-side (my_server.js):

</p>
<pre><code class="js">server.on(&#39;sendToGroup&#39;, function(env, params, allow) {
    if (params.group === &quot;group&quot; &amp;&amp; params.method === &quot;clientsMethod&quot;) {
        allow();
    }
});</code></pre>
<h2>Object: env<span><a class="mark" href="#jxcore_messaging_object_env" id="jxcore_messaging_object_env">#</a></span></h2>
<div class="signature"><ul>
<li><code>ClientId</code> <span class="type">String</span></li>
<li>&#39;ApplicationName` <span class="type">String</span></li>
<li>&#39;SessionID` <span class="type">String</span></li>
<li><code>Index</code> <span class="type">number</span></li>
</div></ul>
<p>This object is passed to some of the methods described in this document. It contains information about a call made from a client&#39;s side.
For example, when a client invokes server&#39;s method by using <code>Call()</code>, the server&#39;s method will receive <code>env</code> object apart from argument passed to <code>Call()</code>.

</p>
<p><code>Index</code> represents id of client&#39;s callback and is used by <code>sendCallback()</code> method.

</p>
<h2>allowedResourceTypes<span><a class="mark" href="#jxcore_messaging_allowedresourcetypes" id="jxcore_messaging_allowedresourcetypes">#</a></span></h2>
<p>List of supported types for resource files.

</p>
<ul>
<li><code>png</code> - image/png</li>
<li><code>jpg</code> - image/jpeg</li>
<li><code>jpeg</code> - image/jpeg</li>
<li><code>gif</code> - image/gif</li>
<li><code>html</code> - text/html</li>
<li><code>css</code> - text/css</li>
<li><code>js</code> - text/javascript</li>
<li><code>woff</code> - application/octet-stream</li>
<li><code>ttf</code> - application/octet-stream</li>
<li><code>svg</code> - application/octet-stream</li>
<li><code>otf</code> - application/octet-stream</li>
<li><code>eot</code> - application/octet-stream</li>
</ul>
<p>If you want to add new <code>avi</code> type, you can do it like this:

</p>
<pre><code class="js">server.allowedResourceTypes.avi = &quot;video/avi&quot;;</code></pre>
<p>Or you can delete the existing one:

</p>
<pre><code class="js">delete server.allowedResourceTypes.woff;</code></pre>
<h2>addJSMethod(name, method)<span><a class="mark" href="#jxcore_messaging_addjsmethod_name_method" id="jxcore_messaging_addjsmethod_name_method">#</a></span></h2>
<div class="signature"><ul>
<li><code>name</code> <span class="type">String</span></li>
<li><code>method</code> <span class="type">Function</span><ul>
<li><code>env</code> <span class="type">Object</span></li>
<li><code>params</code> <span class="type">Object</span></li>
</ul>
</li>
</div></ul>
<p>Adds custom method to the application and it can be called from the client’s side.
Method can receive two parameters: <a href="#jxcore_messaging_object_env"><code>env</code></a> as well as <code>params</code>, which is the value sent by client.

</p>
<p>client-side (index.html):

</p>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;
    jxcore.Call(&quot;chatMessage&quot;, &quot;hello&quot;);
&lt;/script&gt;</code></pre>
<p>server-side (my_server.js):

</p>
<pre><code class="js">server.addJSMethod(&quot;chatMessage&quot;, function (env, params) {
    // params contains &quot;Hello&quot; string
    server.sendToAll(&quot;addText&quot;, params );
});</code></pre>
<h2>getConfig(key)<span><a class="mark" href="#jxcore_messaging_getconfig_key" id="jxcore_messaging_getconfig_key">#</a></span></h2>
<div class="signature"><ul>
<li><code>key</code> <span class="type">String</span></li>
</div></ul>
<p>Get value of application’s parameter.

</p>
<h2>linkAssets(urlPath, JXP)<span><a class="mark" href="#jxcore_messaging_linkassets_urlpath_jxp" id="jxcore_messaging_linkassets_urlpath_jxp">#</a></span></h2>
<div class="signature"><ul>
<li><code>urlPath</code> <span class="type">String</span></li>
<li><code>JXP</code> <span class="type">Object</span></li>
</div></ul>
<p>Links assets embedded inside compiled JX file and defines them as static resource used by the application.

</p>
<p>For information, how to compile JX packages, see <a href="jxcore-feature-packaging-code-protection.html">compile</a> command.

</p>
<p>The <code>urlPath</code> parameter is an url path, from which your application will access the asset files.
Please note, that it will be combined with <code>urlPath</code> provided in <code>setApplication()</code> method.

</p>
<p>The <code>JXP</code> refers to the object, which is embedded inside compiled JX file, and holds contents of JXP project file. You can access the JXP object by calling <code>exports.$JXP</code>.

</p>
<p>Let&#39;s assume, that your JXP file contains asset definition:

</p>
<pre><code class="js">{
    ...
    ...
    &quot;assets&quot;: [
       &quot;README.txt&quot;,
       &quot;Licence.txt&quot;
    ],
    ...
}</code></pre>
<p>Then you can link them to your application in a runtime:

</p>
<pre><code class="js">server.linkAssets(&quot;/files&quot;, exports.$JXP);</code></pre>
<p>Now, we could access it for example with a browser:

</p>
<pre><code>http://host:port/chat/files/README.txt</code></pre>
<p>Please note, that &quot;/chat&quot; part is a root path for entire application (provided in <code>setApplication()</code>), while &quot;/files&quot; part is an argument from the <code>linkAssets()</code>.
Now, the both combine into &quot;/chat/files&quot;.

</p>
<h2>linkResource(urlPath, filePath)<span><a class="mark" href="#jxcore_messaging_linkresource_urlpath_filepath" id="jxcore_messaging_linkresource_urlpath_filepath">#</a></span></h2>
<div class="signature"><ul>
<li><code>urlPath</code> <span class="type">String</span></li>
<li><code>filePath</code> <span class="type">String</span></li>
</div></ul>
<p>Defines static resource file used by the application.

</p>
<p>The <code>urlPath</code> is a path, from which your application will access the resource file. Please note, that it will be combined with <code>urlPath</code> provided in <code>setApplication()</code> method.

</p>
<p>The <code>filePath</code> is server&#39;s filesystem path (relative or absolute) to the resource file.

</p>
<pre><code class="js">server.linkResource(&quot;/app&quot;, [&quot;./index.html&quot;, &quot;text/html&quot; ]);</code></pre>
<p>Now, we could access it for example with a browser:

</p>
<pre><code>http://host:port/chat/app</code></pre>
<p>Please note, that &quot;/chat&quot; part is a root path for entire application (provided in <code>setApplication()</code>), while &quot;/app&quot; part is an argument from the <code>linkResource()</code>.
Now, the both combine into &quot;/chat/app&quot;.

</p>
<h2>linkResourcesFromPath(url, dir)<span><a class="mark" href="#jxcore_messaging_linkresourcesfrompath_url_dir" id="jxcore_messaging_linkresourcesfrompath_url_dir">#</a></span></h2>
<div class="signature"><ul>
<li><code>url</code> <span class="type">String</span></li>
<li><code>dir</code> <span class="type">String</span></li>
</div></ul>
<p>Allows linking multiple resources recursively from a given directory.

</p>
<p>Adding the whole ./assets directory (relative path from JXcore server&#39;s working directory).

</p>
<pre><code class="js">server.linkResourcesFromPath(&quot;/assets/&quot;, &quot;./assets/&quot;);</code></pre>
<p>Now, we could access it for example with a browser:

</p>
<pre><code>http://host:port/chat/assets</code></pre>
<p>Please note, that &quot;/chat&quot; part is a root path for entire application (provided in <code>setApplication()</code>), while &quot;/assets&quot; part is an argument from the <code>linkResourcesFromPath()</code>.
Now, the both combine into &quot;/chat/assets&quot;.

</p>
<h2>sendCallBack(env, params)<span><a class="mark" href="#jxcore_messaging_sendcallback_env_params" id="jxcore_messaging_sendcallback_env_params">#</a></span></h2>
<div class="signature"><ul>
<li><code>env</code> <span class="type">Object</span></li>
<li><code>params</code> <span class="type">Object</span></li>
</div></ul>
<p>Calls the callback method at specific client. The <code>env</code> is the same parameter, which you received as argument for a custom method defined by you with <code>addJSMethod()</code>,
while <code>params</code> is an argument for the callback. It can be anything – string, number or json literal object containing many values.

</p>
<pre><code class="js">server.addJSMethod(&quot;serverMethod&quot;, function (env, params) {
    // server responses to a client by calling it&#39;s callback
    server.sendCallBack(env, params + &quot; World!&quot;);
});</code></pre>
<h2>sendToGroup(groupName, methodName, params)<span><a class="mark" href="#jxcore_messaging_sendtogroup_groupname_methodname_params" id="jxcore_messaging_sendtogroup_groupname_methodname_params">#</a></span></h2>
<div class="signature"><ul>
<li><code>groupName</code> <span class="type">String</span></li>
<li><code>methodName</code> <span class="type">String</span></li>
<li><code>params</code> <span class="type">Object</span></li>
</div></ul>
<p>Sends message to a group of subscribers, currently connected to the application. The <code>methodName</code> is the name of the method invoked on the client&#39;s side (every subscriber of this group should has this method defined), while <code>params</code> is an argument for that method.

</p>
<p>Server can send message to group of subscribers, but they need to subscribe first. See <code>Subscribe()</code>.

</p>
<p>In the code below, whenever client will call server&#39;s <code>sendFromServer()</code> method with &quot;Hello&quot; as params argument, the server for each client subscribed to <em>programmers</em> channel, will invoke his <code>clientCustomMethod()</code> passing there &quot;Hello World!&quot; string.

</p>
<pre><code class="js">server.addJSMethod(&quot;sendFromServer&quot;, function (env, params) {
    server.sendToGroup(&quot;programmers&quot;, &quot;clientCustomMethod&quot;, params + &quot;World!&quot;);
});</code></pre>
<h2>setApplication(applicationName, urlPath, secretKey)<span><a class="mark" href="#jxcore_messaging_setapplication_applicationname_urlpath_secretkey" id="jxcore_messaging_setapplication_applicationname_urlpath_secretkey">#</a></span></h2>
<div class="signature"><ul>
<li><code>applicationName</code> <span class="type">String</span></li>
<li><code>urlPath</code> <span class="type">String</span></li>
<li><code>secretKey</code> <span class="type">String</span></li>
</div></ul>
<p>Defines new application with specified <code>applicationName</code> and default root <code>urlPath</code>. Every assets or resources added to this application will start from this path.

</p>
<p>The <code>secretKey</code> parameter is for encrypting the client locator and can be obtained from jxcore control panel.

</p>
<p>Server-side (<em>my_server.js</em>):

</p>
<pre><code class="js">server.setApplication(&quot;ChatSample&quot;, &quot;/chat&quot;, &quot;NUBISA-STANDARD-KEY-CHANGE-THIS&quot;);</code></pre>
<p>Client-side (<em>index.html</em>):

</p>
<pre><code class="html">&lt;script src=&quot;/chat/jx?ms=connect&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre>
<p>Please note, that the &quot;/chat&quot; part in the url is the <code>urlPath</code> parameter described above.

</p>
<h2>setConfig(key, value)<span><a class="mark" href="#jxcore_messaging_setconfig_key_value" id="jxcore_messaging_setconfig_key_value">#</a></span></h2>
<div class="signature"><ul>
<li><code>key</code> <span class="type">String</span></li>
<li><code>value</code> <span class="type">String</span></li>
</div></ul>
<p>Defines value for application’s parameter. Allows changing server configuration.
See <a href="#jxcore_messaging_configuration">Configuration</a> for detailed information.

</p>
<h2>sendToAll(methodName, params)<span><a class="mark" href="#jxcore_messaging_sendtoall_methodname_params" id="jxcore_messaging_sendtoall_methodname_params">#</a></span></h2>
<div class="signature"><ul>
<li><code>methodName</code> <span class="type">String</span></li>
<li><code>params</code> <span class="type">Object</span></li>
</div></ul>
<p>Send message to all of the clients connected currently to the application.

</p>
<h2>setEngine(app)<span><a class="mark" href="#jxcore_messaging_setengine_app" id="jxcore_messaging_setengine_app">#</a></span></h2>
<div class="signature"><ul>
<li><code>app</code> <span class="type">Object</span></li>
</div></ul>
<p>Defines the server engine (like express)...

</p>
<h2>start(options)<span><a class="mark" href="#jxcore_messaging_start_options" id="jxcore_messaging_start_options">#</a></span></h2>
<div class="signature"><ul>
<li><code>options</code> <span class="type">Object</span></li>
</div></ul>
<p>Starts JXcore application with optional <code>options</code> for the server. Once started, it will be accessible to all clients.

</p>
<h2>subscribeClient(env, groupName)<span><a class="mark" href="#jxcore_messaging_subscribeclient_env_groupname" id="jxcore_messaging_subscribeclient_env_groupname">#</a></span></h2>
<div class="signature"><ul>
<li><code>env</code> <span class="type">Object</span> - see <a href="#jxcore_messaging_object_env">Object: <code>env</code></a></li>
<li><code>groupName</code> <span class="type">String</span></li>
</div></ul>
<p>Subscribes the client to a <code>groupName</code>, or channel. This is server-side equivalent of <code>Subscribe()</code> method from client&#39;s API.

</p>
<p>From now on, messages sent to that group by any other subscriber or server will be received by the client.
Also the client can send messages to this group – see <code>SendToGroup()</code> method.

</p>
<p>This method should be used in one of server&#39;s custom method defined with <code>addJSMethod()</code>,
because it requires the <a href="#jxcore_messaging_object_env"><code>env</code></a> object containing information about client&#39;s call.

</p>
<p>For example, when client calls:

</p>
<pre><code class="js">    jxcore.Call(&quot;someMethod&quot;, true);</code></pre>
<p>on the server-side you can use it to subscribe him to a group:

</p>
<pre><code class="js">server.addJSMethod(&quot;someMethod&quot;, function(env, param) {
    if (param === true) {
        server.subscribeClient(env, &quot;testGroup&quot;);
    }
});</code></pre>
<p>Of course you may apply any logic or algorithm for making decision, whether subscribe the client and how.

</p>
<h2>unSubscribeClient(env, groupName)<span><a class="mark" href="#jxcore_messaging_unsubscribeclient_env_groupname" id="jxcore_messaging_unsubscribeclient_env_groupname">#</a></span></h2>
<div class="signature"><ul>
<li><code>env</code> <span class="type">Object</span> - see <a href="#jxcore_messaging_object_env">Object: <code>env</code></a></li>
<li><code>groupName</code> <span class="type">String</span></li>
</div></ul>
<p>Unsubscribes the client from a <code>groupName</code>, or channel. This is server-side equivalent of <code>Unsubscribe()</code> method from client&#39;s API.

</p>
<p>From now on, messages sent to that group cannot be received by this client.
Also, the client cannot messages to that group.

</p>
<p>The usage is analogous to the <code>subscribeClient()</code> method.

</p>
<p>client-side:

</p>
<pre><code class="js">    jxcore.Call(&quot;someMethod&quot;, false);</code></pre>
<p>server-side:

</p>
<pre><code class="js">server.addJSMethod(&quot;someMethod&quot;, function(env, param) {
    if (param === true) {
        server.subscribeClient(env, &quot;testGroup&quot;);
    } else {
        server.unSubscribeClient(env, &quot;testGroup&quot;);
    }
});</code></pre>
<h1>API JavaScript Client<span><a class="mark" href="#jxcore_messaging_api_javascript_client" id="jxcore_messaging_api_javascript_client">#</a></span></h1>
<h2>Events<span><a class="mark" href="#jxcore_messaging_events_1" id="jxcore_messaging_events_1">#</a></span></h2>
<h3>document.onjxready<span><a class="mark" href="#jxcore_messaging_document_onjxready" id="jxcore_messaging_document_onjxready">#</a></span></h3>
<p>There is a special event <code>document.onjxready</code>, which is called right after the JXcore script is loaded:

</p>
<pre><code class="html">&lt;script src=&quot;/helloworld/jx?ms=connect&quot; type=&quot;text/javascript&quot;&gt;</code></pre>
<p>Inside that event we can start to use jxcore object and for example we attach to the following events: <code>OnClose</code>, <code>OnError</code> and <code>Start()</code> method. The last one is the most important one for us. Please see the comments in the code above to catch the idea.

</p>
<pre><code class="js">&lt;script type=&quot;text/javascript&quot;&gt;

    document.onjxready = function () {

        jxcore.Start(function (status) {

            var send_button = document.getElementById(&#39;send_button&#39;);
            // let&#39;s enable button, right now the script is loaded
            send_button.disabled = &quot;&quot;;

            var msg = document.getElementById(&#39;msg&#39;);
            msg.innerHTML += &quot;Connected.&lt;BR&gt;&quot;;

            var callback = function (s) {
                msg.innerHTML += s + &quot;&lt;BR&gt;&quot;;
            };

            send_button.onclick = function () {
                // let&#39;s call the server-side method &quot;serverMethod&quot; from the client!
                // in turn, as a response, the backend service will invoke
                // client&#39;s local &quot;callback&quot; defined above!
                jxcore.Call(&quot;serverMethod&quot;, &quot;Hello&quot;, callback);
            };
        });

        jxcore.OnClose = function (reconnecting) {
            msg.innerHTML += &quot;Disconnected.&lt;BR&gt;&quot;;
        };

        jxcore.OnError = function (err) {
            msg.innerHTML += err;
        }
    };
&lt;/script&gt;</code></pre>
<h3>OnClose<span><a class="mark" href="#jxcore_messaging_onclose" id="jxcore_messaging_onclose">#</a></span></h3>
<div class="signature"><ul>
<li><code>reconnecting</code> <span class="type">Boolean</span></li>
</div></ul>
<p>This event is fired every time, when the client loses connection with the server.
The <code>reconnecting</code> parameter has a <code>true</code> value, if client already tries to reconnect.

</p>
<pre><code class="js">jxcore.OnClose = function (reconnecting) {
    msg.innerHTML += &quot;Disconnected.&lt;BR&gt;&quot;;
};</code></pre>
<h3>OnError<span><a class="mark" href="#jxcore_messaging_onerror" id="jxcore_messaging_onerror">#</a></span></h3>
<div class="signature"><ul>
<li><code>err</code> <span class="type">String</span></li>
</div></ul>
<p>This event is emitted every time, the error occurs.

</p>
<pre><code class="js">jxcore.OnError = function (err) {
    msg.innerHTML += err;
}</code></pre>
<h3>OnSubscription<span><a class="mark" href="#jxcore_messaging_onsubscription" id="jxcore_messaging_onsubscription">#</a></span></h3>
<div class="signature"><ul>
<li><code>subscribed</code> <span class="type">Boolean</span></li>
<li><code>groupName</code> <span class="type">String</span></li>
</div></ul>
<p>This event is raised when client gets subscribed to a group or unsubscribed from it by a call made from a server-side (<code>subscribeClient()</code> or <code>unSubscribeClient()</code> methods).

</p>
<p>The <code>subscribed</code> value indicates, whether this event was raised as a result of subscription (<code>true</code>) or unsubscription (<code>false</code>) request.
The <code>groupName</code> is the name of the group, for which the event occurred.

</p>
<p>When subscription/unsubscription request was made by a client&#39;s method <code>Subscribe()</code> or <code>Unsubscribe()</code>,
the event <code>OnSubscription</code> is not raised, but instead you may provide the callback for those methods.
Please refer to their description for more details.

</p>
<p>client-side:

</p>
<pre><code class="js">jxcore.Call(&quot;someMethod&quot;, true);

jxcore.OnSubscription = function (subscribed,  group) {
    if (subscribed) {
        alert(&quot;event: subscribed to a group &quot; + group);
    } else {
        alert(&quot;event: unsubscribed from a group &quot; + group);
    }
};</code></pre>
<p>server-side:

</p>
<pre><code class="js">server.addJSMethod(&quot;someMethod&quot;, function(env, param) {
    if (param === true) {
        server.subscribeClient(env, &quot;testGroup&quot;);
    }
});</code></pre>
<h2>Call(methodName, json, cb)<span><a class="mark" href="#jxcore_messaging_call_methodname_json_cb" id="jxcore_messaging_call_methodname_json_cb">#</a></span></h2>
<div class="signature"><ul>
<li><code>methodName</code> <span class="type">String</span></li>
<li><code>json</code> <span class="type">Object</span></li>
<li><code>callback</code> <span class="type">Function</span><ul>
<li><code>param</code> <span class="type">Object</span></li>
</ul>
</li>
</div></ul>
<p>Invokes specific custom method named <code>methodName</code> defined on the server-side and passes to it one parameter <code>json</code>.
The client&#39;s <code>callback</code> is optional, but when provided, it will be called after server completes invoking the method
and will receive <code>param</code> argument sent from the server-side.

</p>
<p>In the example below we call the server-side method &quot;serverMethod&quot; from the client-side.
In turn, as a response, the backend service will invoke the client&#39;s local <code>callback</code> function:

</p>
<pre><code class="js">var callback = function(param) {
    alert(param);
}

jxcore.Call(&quot;serverMethod&quot;, &quot;hello&quot;, callback);</code></pre>
<p>or simply:

</p>
<pre><code class="js">jxcore.Call(&quot;serverMethod&quot;, &quot;hello&quot;, function(param) {
    alert(param);
});</code></pre>
<h2>Close(tx)<span><a class="mark" href="#jxcore_messaging_close_tx" id="jxcore_messaging_close_tx">#</a></span></h2>
<div class="signature"><ul>
<li><code>tx</code> <span class="type">Boolean</span></li>
</div></ul>
<p>Closes client and disconnects from the server.

</p>
<p>The <code>tx</code> parameter is optional. If set to <code>false</code>, the <code>OnClose</code> event will also be invoked with <code>false</code> value as an argument: <code>OnClose(false)</code>.
If <code>true</code> - then <code>OnClose</code> event will not get invoked.

</p>
<h2>GetClientId()<span><a class="mark" href="#jxcore_messaging_getclientid" id="jxcore_messaging_getclientid">#</a></span></h2>
<p>Gets the id of the client, which is an unique string value.

</p>
<h2>ReConnect()<span><a class="mark" href="#jxcore_messaging_reconnect" id="jxcore_messaging_reconnect">#</a></span></h2>
<p>Forces the client to reconnect to the server.

</p>
<h2>SendToGroup(groupName, methodName, json)<span><a class="mark" href="#jxcore_messaging_sendtogroup_groupname_methodname_json" id="jxcore_messaging_sendtogroup_groupname_methodname_json">#</a></span></h2>
<div class="signature"><ul>
<li><code>groupName</code> <span class="type">String</span></li>
<li><code>methodName</code> <span class="type">String</span></li>
<li><code>json</code> <span class="type">Object</span></li>
</div></ul>
<p>Sends message to all of the clients, that have already subscribed to the specific <code>groupName</code>.
The message is passed as <code>json</code> argument to the target&#39;s method named <code>methodName</code>.
The message can be any value, primitive (string, number, etc.) or json literal object.

</p>
<pre><code class="js">document.getElementById(&quot;btnSend&quot;).onclick = function(){
    jxcore.SendToGroup(&quot;programmers&quot;, &quot;addText&quot;, { obj : &quot;value&quot; } );
};</code></pre>
<p>The &quot;addText&quot; method should be available on every client which is subscribed to &quot;programmers&quot; group.
While invoking the &quot;addText&quot; method at each client, the server will pass { obj : &quot;value&quot; } as an argument.

</p>
<h2>Start(cb)<span><a class="mark" href="#jxcore_messaging_start_cb" id="jxcore_messaging_start_cb">#</a></span></h2>
<div class="signature"><ul>
<li><code>callback</code> <span class="type">Function</span><ul>
<li><code>status</code> <span class="type">Boolean</span></li>
</ul>
</li>
</div></ul>
<p>Starts JXcore client. Connects to the server, and when it succeeds - the client’s callback <code>callback</code> is called.

</p>
<pre><code class="js">document.onjxready = function () {
    jxcore.Start(function (status) {

        // here we are, after the client has connected to server
        // we can enable the button now
        var btnSend = document.getElementById(&#39;btnSend&#39;);
        btnSend.disabled = &quot;&quot;;

        // do anything else
        // see tutorials for more usage
    });
};</code></pre>
<h2>Subscribe(groupName, callback)<span><a class="mark" href="#jxcore_messaging_subscribe_groupname_callback" id="jxcore_messaging_subscribe_groupname_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>groupName</code> <span class="type">String</span></li>
<li><code>callback</code> <span class="type">Function</span><ul>
<li><code>groupName</code> <span class="type">String</span></li>
</ul>
</li>
</div></ul>
<p>Subscribes the client to a <code>groupName</code>, or channel. From now on, messages sent to that group by any other subscriber will be received by the client.
Also the client can send messages to this group – see <code>SendToGroup()</code> method.
After the server will successfully subscribe the client to the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.

</p>
<pre><code class="js">jxcore.Subscribe(&quot;programmers&quot;, function(groupName) {
    alert(&quot;subscribed to group: &quot; + groupName);
});</code></pre>
<h2>Unsubscribe(groupName, callback)<span><a class="mark" href="#jxcore_messaging_unsubscribe_groupname_callback" id="jxcore_messaging_unsubscribe_groupname_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>groupName</code> <span class="type">String</span></li>
<li><code>callback</code> <span class="type">Function</span><ul>
<li><code>groupName</code> <span class="type">String</span></li>
</ul>
</li>
</div></ul>
<p>Unsubscribes the client from a <code>groupName</code>, or channel. From now on, messages sent to that group cannot be received by this client.
After the server will successfully unsubscribe the client from the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.

</p>
<pre><code class="js">jxcore.Unsubscribe(&quot;programmers&quot;, function(groupName) {
    alert(&quot;unsubscribed from a group:&quot; + groupName);
});</code></pre>
<h1>API Java Client<span><a class="mark" href="#jxcore_messaging_api_java_client" id="jxcore_messaging_api_java_client">#</a></span></h1>
<p>There is a tutorial showing, how to consume JXcore Messaging API from a <a href="http://jxcore.com/messaging-api/#post-665">Java Client</a>.

</p>
<h2>Events<span><a class="mark" href="#jxcore_messaging_events_2" id="jxcore_messaging_events_2">#</a></span></h2>
<p>Messaging module for Java defines events in a separate class <code>ClientEvents</code>.
In order to listen for client&#39;s events, we need to instantiate this class and assign to <code>client.Events</code> property:

</p>
<pre><code class="java">import jxcore.*;

jxcore.ClientEvents events = new ClientEvents(){
    @Override
    public void OnErrorReceived(Client c, String Message) {
        // Error received
    }
    @Override
    public void OnClientConnected(Client c) {
        // Client is connected
    }
    @Override
    public void OnClientDisconnected(Client c) {
        // Client is disconnected
    }
    @Override
    public void OnEventLog(Client c, String log, LogLevel level) {
        // get the event log from here
    }
    @Override
    public void OnSubscription(Client c, Boolean subscribed, String group) {
        // Client was subscribed to a group or unsubscribed from a group
        // by a server-side call
    }
};
//now we may define this listener into our Client instance
client.Events = event;</code></pre>
<h3>OnErrorReceived<span><a class="mark" href="#jxcore_messaging_onerrorreceived" id="jxcore_messaging_onerrorreceived">#</a></span></h3>
<div class="signature"><ul>
<li><code>client</code> <span class="type">jxcore.Client</span></li>
<li><code>message</code> <span class="type">String</span></li>
</div></ul>
<p>This event is emitted whenever an error occurs at the <code>client</code>.

</p>
<h3>OnClientConnected<span><a class="mark" href="#jxcore_messaging_onclientconnected" id="jxcore_messaging_onclientconnected">#</a></span></h3>
<div class="signature"><ul>
<li><code>client</code> <span class="type">jxcore.Client</span></li>
</div></ul>
<p>This event is emitted after the <code>client</code> successfully connects to the server.

</p>
<h3>OnClientDisconnected<span><a class="mark" href="#jxcore_messaging_onclientdisconnected" id="jxcore_messaging_onclientdisconnected">#</a></span></h3>
<div class="signature"><ul>
<li><code>client</code> <span class="type">jxcore.Client</span></li>
</div></ul>
<p>This event is emitted when the <code>client</code> loses its connection with the server.

</p>
<h3>OnEventLog<span><a class="mark" href="#jxcore_messaging_oneventlog" id="jxcore_messaging_oneventlog">#</a></span></h3>
<div class="signature"><ul>
<li><code>client</code> <span class="type">jxcore.Client</span></li>
<li><code>log</code> <span class="type">String</span></li>
<li><code>level</code> <span class="type">jxcore.LogLevel</span></li>
</div></ul>
<p>This event is fired whenever the <code>client</code> logs an information <code>log</code> message. The <code>level</code> parameter is an enumeration value and can have one of the following: <em>Informative</em> or <em>Critical</em>.

</p>
<h3>OnSubscription<span><a class="mark" href="#jxcore_messaging_onsubscription_1" id="jxcore_messaging_onsubscription_1">#</a></span></h3>
<div class="signature"><ul>
<li><code>client</code> <span class="type">jxcore.Client</span></li>
<li><code>subscribed</code> <span class="type">Boolean</span></li>
<li><code>groupName</code> <span class="type">String</span></li>
</div></ul>
<p>This event is raised when client gets subscribed to a group or unsubscribed from it by a call made from a server-side (<code>subscribeClient()</code> or <code>unSubscribeClient()</code> methods).

</p>
<p>The <code>subscribed</code> value indicates, whether this event was raised as a result of subscription (<code>true</code>) or unsubscription (<code>false</code>) request.
The <code>groupName</code> is the name of the group, for which the event occurred.

</p>
<p>When subscription/unsubscription request was made by a client&#39;s method <code>Subscribe()</code> or <code>Unsubscribe()</code>, the event <code>OnSubscription</code> is not raised, but instead you may provide the callback for those methods.
Please refer to their description for more details.

</p>
<h2>new Client(localTarget, appName, appKey, url, port, secure)<span><a class="mark" href="#jxcore_messaging_new_client_localtarget_appname_appkey_url_port_secure" id="jxcore_messaging_new_client_localtarget_appname_appkey_url_port_secure">#</a></span></h2>
<div class="signature"><ul>
<li><code>localTarget</code> <span class="type">Object</span></li>
<li><code>appName</code> <span class="type">String</span></li>
<li><code>appKey</code> <span class="type">String</span></li>
<li><code>url</code> <span class="type">String</span></li>
<li><code>port</code> <span class="type">int</span></li>
<li><code>secure</code> <span class="type">boolean</span></li>
<li><code>resetUID</code> <span class="type">boolean</span></li>
</div></ul>
<p>Creates an instance of JXcore Java Client with specified application name <code>appName</code> and application key <code>appKey</code> (which is obtainable from web control panel).
The <code>url</code> parameter specifies JXcore server URL, e.g. <em>sampledomain.com</em> or <em>120.1.2.3</em>. You can also enable SSL support with <code>secure</code> parameter.

</p>
<p>Setting <code>resetUID</code> as <code>true</code> will reset the unique instance id (session id).

</p>
<p>The first argument <code>localTarget</code> is an instance of a local class, which will be answering the calls from server.
In that class you will specify client methods, which will be callable by other clients or the server itself.

</p>
<pre><code class="java">import jxcore.*;

Client client = new Client(new CustomMethods(), &quot;channels&quot;,
    &quot;NUBISA-STANDARD-KEY-CHANGE-THIS&quot;, &quot;localhost&quot;, 8000, false, true);</code></pre>
<h2>Call(methodName, params, callback)<span><a class="mark" href="#jxcore_messaging_call_methodname_params_callback" id="jxcore_messaging_call_methodname_params_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>methodName</code> <span class="type">String</span></li>
<li><code>params</code> <span class="type">Object</span></li>
<li><code>callback</code> <span class="type">jxcore.Callback</span></li>
</div></ul>
<p>Invokes specific custom method <code>methodName</code> defined on the server-side and passes to it <code>params</code> value. The <code>methodName</code> should also contain the class name and the namespace, e.g. <em>com.example.MyClass.MyMethod</em>.

</p>
<p>The optional parameter <code>callback</code> is the client’s function, which will be called after server completes invoking the method.

</p>
<p>In the example below we call the server-side method <em>serverMethod</em> from the client-side.
In turn, as a response, the backend service will invoke the client&#39;s local <code>callback</code> function:

</p>
<pre><code class="java">client.Call(&quot;serverMethod&quot;, &quot;Hello&quot;, callback);</code></pre>
<h2>Connect()<span><a class="mark" href="#jxcore_messaging_connect" id="jxcore_messaging_connect">#</a></span></h2>
<p>Starts the client, connects to the server. Returns a boolean value based on the result.

</p>
<pre><code class="java">if (client.Connect()) {
    System.out.println(&quot;ready!&quot;);
}</code></pre>
<h2>getClientId()<span><a class="mark" href="#jxcore_messaging_getclientid_1" id="jxcore_messaging_getclientid_1">#</a></span></h2>
<p>Gets the string containing unique id of the client.

</p>
<h2>SendToGroup(String groupName, String methodName, Object params)<span><a class="mark" href="#jxcore_messaging_sendtogroup_string_groupname_string_methodname_object_params" id="jxcore_messaging_sendtogroup_string_groupname_string_methodname_object_params">#</a></span></h2>
<div class="signature"><ul>
<li><code>groupName</code> <span class="type">String</span></li>
<li><code>methodName</code> <span class="type">String</span></li>
<li><code>params</code> <span class="type">Object</span></li>
</div></ul>
<p>Sends message to all clients, that have already subscribed to the specific <code>groupName</code>. The message is passed as <code>params</code> argument to the target&#39;s method named <code>methodName</code>.

</p>
<p>The &quot;addText&quot; method should be available on every client, which is subscribed to <em>programmers</em> group.
While invoking the <em>addText</em> method at each client, the server will pass &quot;Hello from client!&quot; as an argument.

</p>
<pre><code class="java">client.SendToGroup(&quot;programmers&quot;, &quot;addText&quot;, &quot;Hello from client!&quot;);</code></pre>
<h2>Subscribe(groupName, callback)<span><a class="mark" href="#jxcore_messaging_subscribe_groupname_callback_1" id="jxcore_messaging_subscribe_groupname_callback_1">#</a></span></h2>
<div class="signature"><ul>
<li><code>groupName</code> <span class="type">String</span></li>
<li><code>callback</code> <span class="type">jxcore.Callback</span><ul>
<li><code>groupName</code> <span class="type">String</span></li>
</ul>
</li>
</div></ul>
<p>Subscribes the client to a <code>groupName</code>, or channel. From now on, messages sent to that group by any other subscriber will be received by the client.
Also the client can send messages to this group – see <code>SendToGroup()</code> method.
After the server will successfully subscribe the client to the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.

</p>
<pre><code class="java">try {
     client.Subscribe(&quot;programmers&quot;, new Callback() {
         @Override
         public void call(Object o) throws Exception {
             System.out.println(&quot;Subscribed to &quot; + o.toString());
             client.SendToGroup(&quot;programmers&quot;, &quot;clientMethod&quot;,
             &quot;Hello from client!&quot;);
         }
     });
} catch (Exception e) {
     System.out.println(&quot;Cannot subscribe.&quot;);
}</code></pre>
<h2>Unsubscribe(group, callback)<span><a class="mark" href="#jxcore_messaging_unsubscribe_group_callback" id="jxcore_messaging_unsubscribe_group_callback">#</a></span></h2>
<div class="signature"><ul>
<li><code>groupName</code> <span class="type">String</span></li>
<li><code>callback</code> <span class="type">jxcore.Callback</span><ul>
<li><code>groupName</code> <span class="type">String</span></li>
</ul>
</li>
</div></ul>
<p>Unsubscribes the client from a <code>groupName</code>, or channel. From now on, messages sent to that group cannot be received by this client.
After the server will successfully unsubscribe the client from the <code>groupName</code>, the client&#39;s <code>callback</code> will be called.

</p>
<pre><code class="java">try {
     client.Unsubscribe(&quot;programmers&quot;, new Callback() {
         @Override
         public void call(Object o) throws Exception {
             System.out.println(&quot;Unsubscribed from &quot; + o.toString());
         }
     });
} catch (Exception e) {
     System.out.println(&quot;Cannot unsubscribe.&quot;);
}</code></pre>

          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://nubisa.com" class="nubisa">Nubisa</a>
        <ul class="clearfix">
            <li><a href="http://jxcore.com/" class="home">Home</a></li>
            <li><a href="http://jxcore.com/downloads/" class="download">Download</a></li>
            <li><a href="index.html" class="docs current">Docs</a></li>
            <li><a href="http://jxcore.com/tutorials/" class="docs current">Tutorials</a></li>
            <li><a href="https://github.com/Nubisa/jxdocs/issues/" class="about">Issues</a></li>
            <li><a href="http://jxcore.com/blog" class="blog">Blog</a></li>
            <li><a href="https://twitter.com/nodejx" class="twitter">Follow us on Twitter</a></li>
        </ul>

        <p>Copyright <a href="http://nubisa.com/">Nubisa, Inc.</a> 2014. View <a href="http://jxcore.com/document/eula/">license</a>.</p>
    </div>

  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
    <script>
        var _gaq=[['_setAccount','UA-47144445-1'],['_trackPageview']];
        (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
    </script>
</body>
</html>

